name: Build / publish

on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, reopened, synchronize]
  release:
    types: [published]

jobs:
  test:
    timeout-minutes: 90  # Fail fast if job exceeds 90 minutes
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            powershell_version: "7.4.11"
          - os: windows-latest
            powershell_version: "7.4.11"
          - os: ubuntu-latest
            powershell_version: latest
          - os: windows-latest
            powershell_version: latest
          - os: windows-latest
            powershell_version: '5'

    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0  # Fetch all history for tags
      - if: ${{ matrix.powershell_version != '5' }}
        name: Install PowerShell ${{ matrix.powershell_version }}
        uses: PSModule/install-powershell@v1
        with:
          Version: ${{ matrix.powershell_version }}
      - name: Build
        shell: pwsh
        run: |       
          $manifestpath = "Rnwood.Dataverse.Data.PowerShell/Rnwood.Dataverse.Data.PowerShell.psd1"
          
          if ($env:GITHUB_REF -like "refs/tags/*") {
            # Release build - use tag version
            $versionnumber = $env:GITHUB_REF -replace "refs/tags/", ""
            (get-content -raw -encoding UTF8 $manifestpath ) -replace "ModuleVersion ?=.*", "ModuleVersion = `"$versionnumber`"" | set-content -encoding UTF8 $manifestpath
            Write-Host "Release version: $versionnumber"
            
            # Generate release notes for stable release (compare to last stable release)
            Write-Host "Generating release notes for stable release..."
            $allTags = git tag --list --sort=-version:refname 2>$null
            $stableReleases = $allTags | Where-Object { $_ -notmatch '-' } | Select-Object -First 2
            
            if ($stableReleases.Count -ge 2) {
              $previousRelease = $stableReleases[1]
              Write-Host "Comparing to previous stable release: $previousRelease"
              $releaseNotes = & ./scripts/Get-ReleaseNotes.ps1 -FromRef $previousRelease -ToRef "HEAD" -Format markdown
              $releaseNotesText = & ./scripts/Get-ReleaseNotes.ps1 -FromRef $previousRelease -ToRef "HEAD" -Format text
            } else {
              Write-Host "No previous stable release found, using all commits"
              $releaseNotes = "Initial release"
              $releaseNotesText = "Initial release"
            }
            
            # Save release notes for later steps
            $releaseNotes | Out-File -FilePath release-notes.md -Encoding utf8
            $releaseNotesText | Out-File -FilePath release-notes.txt -Encoding utf8
          } elseif ($env:GITHUB_REF -eq "refs/heads/main" -or $env:GITHUB_EVENT_NAME -eq "pull_request") {
            # CI build on main branch or PR - auto-determine version using conventional commits
            
            # Get all tags sorted by version
            $allTags = git tag --list --sort=-version:refname 2>$null
            
            # Find the latest stable release (no prerelease suffix)
            $latestStableTag = $allTags | Where-Object { $_ -notmatch '-' } | Select-Object -First 1
            if (-not $latestStableTag) {
              $latestStableTag = "0.0.0"
            }
            
            # Parse version from stable tag
            if ($latestStableTag -match '^v?(\d+\.\d+\.\d+)') {
              $baseVersion = $matches[1]
            } else {
              $baseVersion = "0.0.0"
            }
            
            Write-Host "Latest stable release: $latestStableTag (version: $baseVersion)"
            
            # Determine next version based on conventional commits
            if ($env:GITHUB_EVENT_NAME -eq "pull_request") {
              # For PRs, analyze PR title for conventional commits
              # Note: We don't use existing prereleases for PRs since each PR is independent
              # and we don't care about version clashes in PR branches
              Write-Host "PR detected - analyzing PR title for conventional commits"
              
              # Get PR title from GitHub event
              $eventPath = $env:GITHUB_EVENT_PATH
              if (Test-Path $eventPath) {
                $event = Get-Content $eventPath -Raw | ConvertFrom-Json
                $prTitle = $event.pull_request.title
                
                Write-Host ""
                Write-Host "PR Title: $prTitle"
                
                # Use PR title as the commit message for analysis
                $commitMessages = @($prTitle)
                
                # Calculate version based on PR title only (no prerelease comparison)
                $nextVersion = & ./scripts/Get-NextVersion.ps1 -BaseVersion $baseVersion -CommitMessages $commitMessages
                Write-Host "Next version determined from PR title: $nextVersion"
                $baseVersion = $nextVersion
              }
            } else {
              # For main branch, analyze recent commits and use existing prereleases
              # to prevent double-bumping when multiple PRs with same change type are merged
              Write-Host "Main branch detected - analyzing recent commits"
              
              # Find all prerelease tags since the latest stable release
              $existingPrereleases = @()
              if ($latestStableTag -ne "0.0.0") {
                # Get all tags that come after the stable release and have a prerelease suffix
                $tagsAfterStable = git tag --list --sort=-version:refname --merged HEAD 2>$null | 
                  Where-Object { $_ -match '-' }
                
                # Filter to only prereleases that are based on or after the stable version
                foreach ($tag in $tagsAfterStable) {
                  if ($tag -match '^v?(\d+)\.(\d+)\.(\d+)') {
                    $tagVersion = "$($matches[1]).$($matches[2]).$($matches[3])"
                    # Parse tag version
                    if ($tagVersion -match '^(\d+)\.(\d+)\.(\d+)$') {
                      $tagMajor = [int]$matches[1]
                      $tagMinor = [int]$matches[2]
                      $tagPatch = [int]$matches[3]
                      
                      # Parse base version
                      if ($baseVersion -match '^(\d+)\.(\d+)\.(\d+)$') {
                        $baseMajor = [int]$matches[1]
                        $baseMinor = [int]$matches[2]
                        $basePatch = [int]$matches[3]
                        
                        # Check if tag version is >= base version
                        $isNewerOrEqual = $false
                        if ($tagMajor -gt $baseMajor) {
                          $isNewerOrEqual = $true
                        } elseif ($tagMajor -eq $baseMajor -and $tagMinor -gt $baseMinor) {
                          $isNewerOrEqual = $true
                        } elseif ($tagMajor -eq $baseMajor -and $tagMinor -eq $baseMinor -and $tagPatch -ge $basePatch) {
                          $isNewerOrEqual = $true
                        }
                        
                        if ($isNewerOrEqual) {
                          $existingPrereleases += $tag
                        }
                      }
                    }
                  }
                }
              }
              
              if ($existingPrereleases.Count -gt 0) {
                Write-Host "Found $($existingPrereleases.Count) existing prerelease(s) since stable:"
                $existingPrereleases | ForEach-Object { Write-Host "  - $_" }
              } else {
                Write-Host "No existing prereleases found since stable release"
              }
              
              # Get commits since last stable tag
              if ($latestStableTag -eq "0.0.0") {
                Write-Host "No previous tag found, using all commits"
                $commitsSinceTag = git log --format="%s" 2>$null
              } else {
                # Get commits since last stable tag with error handling
                Write-Host "Getting commits since tag: $latestStableTag"
                $commitsSinceTag = git log "$latestStableTag..HEAD" --format="%s" 2>$null
              }
              
              if ($commitsSinceTag) {
                $commitMessages = $commitsSinceTag -split "`n" | Where-Object { $_ -match '\S' }
                
                Write-Host "Commits since last stable tag:"
                $commitMessages | ForEach-Object { Write-Host "  - $_" }
                
                # Use Get-NextVersion script to determine version bump with prerelease comparison
                $params = @{
                  BaseVersion = $baseVersion
                  CommitMessages = $commitMessages
                }
                if ($existingPrereleases.Count -gt 0) {
                  $params.ExistingPrereleases = $existingPrereleases
                }
                $nextVersion = & ./scripts/Get-NextVersion.ps1 @params
                Write-Host "Next version determined from commits: $nextVersion"
                $baseVersion = $nextVersion
              } else {
                Write-Host "No commits since last stable tag, defaulting to patch bump"
                # Use Get-NextVersion with empty messages (defaults to patch)
                $params = @{
                  BaseVersion = $baseVersion
                  CommitMessages = @()
                }
                if ($existingPrereleases.Count -gt 0) {
                  $params.ExistingPrereleases = $existingPrereleases
                }
                $baseVersion = & ./scripts/Get-NextVersion.ps1 @params
              }
            }
            
            # Get current date in yyyyMMdd format (UTC)
            $nowUtc = [DateTime]::UtcNow
            $dateString = $nowUtc.ToString("yyyyMMdd")
            
            # Use GitHub Actions run number as sequence number for better reliability
            # GITHUB_RUN_NUMBER is a sequential number that increments with each workflow run
            # Falls back to 1 if not in GitHub Actions environment
            $runNumber = $env:GITHUB_RUN_NUMBER
            if (-not $runNumber) {
              $runNumber = 1
            }
            
            # Build CI version with date-based prerelease suffix: ci<yyyyMMdd><seqNum>
            # where seqNum is zero-padded to 3 digits for SemVer 1.0 compliance (no dots allowed)
            $seqNum = "{0:000}" -f [int]$runNumber
            $prereleaseString = "ci$dateString$seqNum"
            
            # Update manifest with base version and prerelease in one operation
            $content = get-content -raw -encoding UTF8 $manifestpath
            
            # Update ModuleVersion
            $content = $content -replace "ModuleVersion ?=.*", "ModuleVersion = `"$baseVersion`""
            
            # Add prerelease to PrivateData.PSData if not already present
            if ($content -notmatch "Prerelease\s*=") {
              if ($content -match "PrivateData\s*=\s*@\{") {
                if ($content -match "PSData\s*=\s*@\{") {
                  # PSData section exists - add Prerelease field
                  $content = $content -replace "(PSData\s*=\s*@\{)", "`$1`n`t`tPrerelease = '$prereleaseString'"
                } else {
                  # Add PSData section with Prerelease
                  $content = $content -replace "(PrivateData\s*=\s*@\{)", "`$1`n`tPSData = @{`n`t`tPrerelease = '$prereleaseString'`n`t}"
                }
              }
            }
            
            # Write updated content once
            $content | set-content -encoding UTF8 $manifestpath
            
            Write-Host "CI version: $baseVersion-$prereleaseString"
            # Save version for later steps
            "$baseVersion-$prereleaseString" | Out-File -FilePath ci-version.txt -Encoding utf8
            
            # Generate release notes for CI build (compare to last prerelease)
            Write-Host "Generating release notes for CI build..."
            $allTags = git tag --list --sort=-version:refname 2>$null
            $prereleases = $allTags | Where-Object { $_ -match '-' } | Select-Object -First 1
            
            if ($prereleases) {
              $previousPrerelease = $prereleases
              Write-Host "Comparing to previous prerelease: $previousPrerelease"
              $releaseNotes = & ./scripts/Get-ReleaseNotes.ps1 -FromRef $previousPrerelease -ToRef "HEAD" -Format markdown
              $releaseNotesText = & ./scripts/Get-ReleaseNotes.ps1 -FromRef $previousPrerelease -ToRef "HEAD" -Format text
            } else {
              # If no prerelease found, compare to last stable tag
              $latestStableTag = $allTags | Where-Object { $_ -notmatch '-' } | Select-Object -First 1
              if ($latestStableTag) {
                Write-Host "No previous prerelease found, comparing to last stable: $latestStableTag"
                $releaseNotes = & ./scripts/Get-ReleaseNotes.ps1 -FromRef $latestStableTag -ToRef "HEAD" -Format markdown
                $releaseNotesText = & ./scripts/Get-ReleaseNotes.ps1 -FromRef $latestStableTag -ToRef "HEAD" -Format text
              } else {
                Write-Host "No previous releases found, using all commits"
                $releaseNotes = "Initial prerelease"
                $releaseNotesText = "Initial prerelease"
              }
            }
            
            # Save release notes for later steps
            $releaseNotes | Out-File -FilePath release-notes.md -Encoding utf8
            $releaseNotesText | Out-File -FilePath release-notes.txt -Encoding utf8
          }

          dotnet build -c Release ./Rnwood.Dataverse.Data.PowerShell/Rnwood.Dataverse.Data.PowerShell.csproj
          if (test-path out/Rnwood.Dataverse.Data.PowerShell) {
            remove-item -force -recurse out/Rnwood.Dataverse.Data.PowerShell
          }
          copy-item -recurse Rnwood.Dataverse.Data.PowerShell\bin\Release\netstandard2.0 out/Rnwood.Dataverse.Data.PowerShell
      - if: ${{ matrix.powershell_version != '5' }}
        name: Test - pwsh (Standard + E2E in parallel)
        id: test-pwsh
        timeout-minutes: 90  # Tests expected to complete in < 90 minutes
        shell: pwsh
        env:
          E2ETESTS_URL: ${{ vars.E2ETESTS_URL }}
          E2ETESTS_CLIENTID: ${{ vars.E2ETESTS_CLIENTID }}
          E2ETESTS_CLIENTSECRET: ${{ secrets.E2ETESTS_CLIENTSECRET }}
        run: |
          Write-Host "Using PowerShell $($PSVersionTable.PSVersion)"    
          $env:TESTMODULEPATH=(resolve-path "out/Rnwood.Dataverse.Data.PowerShell")

          Install-Module -Force -Scope CurrentUser -SkipPublisherCheck Pester -MinimumVersion 5.0.0 -MaximumVersion 5.99.99
          
          # Start standard tests and E2E tests in parallel
          
          # Capture current working directory to pass to background jobs
          $workingDir = Get-Location
          
          # Job 1: Standard tests
          $standardTestsJob = Start-Job -ScriptBlock {
              param($modulePath, $workDir)
              
              # Set working directory for this job
              Set-Location $workDir
              
              $env:TESTMODULEPATH = $modulePath
              
              $testFiles = Get-ChildItem 'tests/*.Tests.ps1' -Exclude 'Performance-Investigation.Tests.ps1' | Select-Object -ExpandProperty FullName
              
              # Start a job for each test file
              $jobs = $testFiles | ForEach-Object {
                  $testFile = $_
                  Start-Job -ScriptBlock {
                      param($testFilePath, $modulePath)
                      
                      $env:TESTMODULEPATH = $modulePath
                      
                      # Run each test file independently
                      $config = New-PesterConfiguration
                      $config.Run.Path = $testFilePath
                      $config.Run.PassThru = $true
                      $config.Output.Verbosity = 'Normal'
                      $config.Should.ErrorAction = 'Continue'
                      
                      $result = Invoke-Pester -Configuration $config
                      
                      # Return result with filename for aggregation
                      [PSCustomObject]@{
                          File = (Split-Path $testFilePath -Leaf)
                          TotalCount = $result.TotalCount
                          PassedCount = $result.PassedCount
                          FailedCount = $result.FailedCount
                          SkippedCount = $result.SkippedCount
                          DurationSeconds = $result.Duration.TotalSeconds
                          Failed = $result.Failed
                      }
                  } -ArgumentList $testFile, $modulePath
              }
              
              # Wait for all test file jobs to complete with streaming output
              while ($jobs | Where-Object { $_.State -eq 'Running' }) {
                  foreach ($job in $jobs) {
                      if ($job.HasMoreData) {
                          $job | Receive-Job
                      }
                  }
                  Start-Sleep -Milliseconds 100
              }
              
              # Get final results
              $results = $jobs | Receive-Job
              $jobs | Remove-Job
              
              return $results
          } -ArgumentList $env:TESTMODULEPATH, $workingDir
          
          # Job 2: E2E tests (Module.Tests.ps1 for all matrix combinations)
          $e2eTestsJob = Start-Job -ScriptBlock {
              param($modulePath, $e2eUrl, $e2eClientId, $e2eClientSecret, $osType, $psVersion, $workDir)
              
              # Set working directory for this job
              Set-Location $workDir
              
              $env:TESTMODULEPATH = $modulePath
              $env:E2ETESTS_URL = $e2eUrl
              $env:E2ETESTS_CLIENTID = $e2eClientId
              $env:E2ETESTS_CLIENTSECRET = $e2eClientSecret
              
              $config = New-PesterConfiguration
              $config.Run.Path = 'e2e-tests/Module.Tests.ps1'
              $config.Run.PassThru = $true
              $config.Output.Verbosity = 'Normal'
              $config.Filter.ExcludeTag = 'LongRunning'
              
              $result = Invoke-Pester -Configuration $config
              
              # Check if we should also run all other e2e tests (Windows Latest only)
              $shouldRunAdditionalTests = ($osType -eq 'windows-latest' -and $psVersion -eq 'latest')
              
              if ($shouldRunAdditionalTests) {
                  # Run Metadata tests SEQUENTIALLY (they cannot run in parallel)
                  $metadataTests = @(
                      'e2e-tests/AttributeMetadata.Tests.ps1',
                      'e2e-tests/EntityMetadata.Tests.ps1',
                      'e2e-tests/OptionSetMetadata.Tests.ps1',
                      'e2e-tests/RelationshipMetadata.Tests.ps1'
                  )
                  
                  $metadataResults = @()
                  foreach ($testFile in $metadataTests) {
                      $testConfig = New-PesterConfiguration
                      $testConfig.Run.Path = $testFile
                      $testConfig.Run.PassThru = $true
                      $testConfig.Output.Verbosity = 'Normal'
                      $testConfig.Filter.ExcludeTag = 'LongRunning'
                      
                      $testResult = Invoke-Pester -Configuration $testConfig
                      $metadataResults += $testResult
                  }
                  
                  # Run non-Metadata tests in PARALLEL
                  $nonMetadataTests = @(
                      'e2e-tests/AppModule.Tests.ps1',
                      'e2e-tests/FormManipulation.Tests.ps1',
                      'e2e-tests/InvokeDataverseRequest.Tests.ps1',
                      'e2e-tests/PluginManagement.Tests.ps1',
                      'e2e-tests/RecordAccess.Tests.ps1',
                      'e2e-tests/Sitemap.Tests.ps1',
                      'e2e-tests/SolutionComponent.Tests.ps1'
                  )
                  
                  $nonMetadataJobs = $nonMetadataTests | ForEach-Object {
                      $testFile = $_
                      Start-Job -ScriptBlock {
                          param($testFilePath, $modulePath, $e2eUrl, $e2eClientId, $e2eClientSecret)
                          
                          $env:TESTMODULEPATH = $modulePath
                          $env:E2ETESTS_URL = $e2eUrl
                          $env:E2ETESTS_CLIENTID = $e2eClientId
                          $env:E2ETESTS_CLIENTSECRET = $e2eClientSecret
                          
                          $config = New-PesterConfiguration
                          $config.Run.Path = $testFilePath
                          $config.Run.PassThru = $true
                          $config.Output.Verbosity = 'Normal'
                          $config.Filter.ExcludeTag = 'LongRunning'
                          
                          $result = Invoke-Pester -Configuration $config
                          
                          # Return result with filename
                          [PSCustomObject]@{
                              File = (Split-Path $testFilePath -Leaf)
                              TotalCount = $result.TotalCount
                              PassedCount = $result.PassedCount
                              FailedCount = $result.FailedCount
                              SkippedCount = $result.SkippedCount
                              DurationSeconds = $result.Duration.TotalSeconds
                              Failed = $result.Failed
                          }
                      } -ArgumentList $testFile, $modulePath, $e2eUrl, $e2eClientId, $e2eClientSecret
                  }
                  
                  # Wait for non-Metadata tests with streaming output
                  while ($nonMetadataJobs | Where-Object { $_.State -eq 'Running' }) {
                      foreach ($job in $nonMetadataJobs) {
                          if ($job.HasMoreData) {
                              $job | Receive-Job
                          }
                      }
                      Start-Sleep -Milliseconds 100
                  }
                  
                  # Get final results
                  $nonMetadataResults = $nonMetadataJobs | Receive-Job
                  $nonMetadataJobs | Remove-Job
                  
                  # Combine results
                  return @{
                      ModuleTests = $result
                      MetadataTests = $metadataResults
                      NonMetadataTests = $nonMetadataResults
                  }
              }
              
              return @{
                  ModuleTests = $result
                  MetadataTests = $null
                  NonMetadataTests = $null
              }
          } -ArgumentList $env:TESTMODULEPATH, $env:E2ETESTS_URL, $env:E2ETESTS_CLIENTID, $env:E2ETESTS_CLIENTSECRET, "${{ matrix.os }}", "${{ matrix.powershell_version }}", $workingDir
          
          # Wait for both jobs to complete and show progress
          # Poll jobs to show streaming output
          while ($standardTestsJob.State -eq 'Running' -or $e2eTestsJob.State -eq 'Running') {
              # Receive any available output without waiting
              if ($standardTestsJob.HasMoreData) {
                  $standardTestsJob | Receive-Job
              }
              if ($e2eTestsJob.HasMoreData) {
                  $e2eTestsJob | Receive-Job  
              }
              Start-Sleep -Milliseconds 100
          }
          
          # Get final results
          $standardResults = $standardTestsJob | Receive-Job
          $e2eResults = $e2eTestsJob | Receive-Job
          
          Remove-Job $standardTestsJob, $e2eTestsJob
          
          # Process standard test results
          Write-Host ""
          Write-Host "=== Standard Tests Results ===" -ForegroundColor Cyan
          $totalTests = ($standardResults | Measure-Object -Property TotalCount -Sum).Sum
          $totalPassed = ($standardResults | Measure-Object -Property PassedCount -Sum).Sum
          $totalFailed = ($standardResults | Measure-Object -Property FailedCount -Sum).Sum
          $totalSkipped = ($standardResults | Measure-Object -Property SkippedCount -Sum).Sum
          $totalDurationSeconds = ($standardResults | Measure-Object -Property DurationSeconds -Sum).Sum
          
          Write-Host "  Total:   $totalTests" -ForegroundColor White
          Write-Host "  Passed:  $totalPassed" -ForegroundColor Green
          Write-Host "  Failed:  $totalFailed" -ForegroundColor $(if ($totalFailed -gt 0) { "Red" } else { "Green" })
          Write-Host "  Skipped: $totalSkipped" -ForegroundColor Yellow
          Write-Host "  Duration: $($totalDurationSeconds)s" -ForegroundColor White
          
          $hasFailures = $false
          
          if ($totalFailed -gt 0) {
              $hasFailures = $true
              Write-Host ""
              Write-Host "Failed Standard Tests:" -ForegroundColor Red
              foreach ($result in $standardResults | Where-Object { $_.FailedCount -gt 0 }) {
                  Write-Host "  File: $($result.File)" -ForegroundColor Yellow
                  foreach ($test in $result.Failed) {
                      Write-Host "    - $($test.ExpandedPath)" -ForegroundColor Red
                      if ($test.ErrorRecord) {
                          Write-Host "      $($test.ErrorRecord.Exception.Message)" -ForegroundColor Gray
                      }
                  }
              }
          }
          
          # Process E2E test results
          Write-Host ""
          Write-Host "=== E2E Tests Results ===" -ForegroundColor Cyan
          
          $e2eModuleResult = $e2eResults.ModuleTests
          Write-Host "Module.Tests.ps1:"
          Write-Host "  Total:   $($e2eModuleResult.TotalCount)" -ForegroundColor White
          Write-Host "  Passed:  $($e2eModuleResult.PassedCount)" -ForegroundColor Green
          Write-Host "  Failed:  $($e2eModuleResult.FailedCount)" -ForegroundColor $(if ($e2eModuleResult.FailedCount -gt 0) { "Red" } else { "Green" })
          Write-Host "  Skipped: $($e2eModuleResult.SkippedCount)" -ForegroundColor Yellow
          Write-Host "  Duration: $($e2eModuleResult.Duration.TotalSeconds)s" -ForegroundColor White
          
          if ($e2eModuleResult.FailedCount -gt 0) {
              $hasFailures = $true
              Write-Host ""
              Write-Host "Failed E2E Module Tests:" -ForegroundColor Red
              foreach ($test in $e2eModuleResult.Failed) {
                  Write-Host "  - $($test.ExpandedPath)" -ForegroundColor Red
                  if ($test.ErrorRecord) {
                      Write-Host "    $($test.ErrorRecord.Exception.Message)" -ForegroundColor Gray
                  }
              }
          }
          
          if ($e2eResults.MetadataTests) {
              Write-Host ""
              Write-Host "Metadata E2E Tests (Sequential):"
              
              $totalMetadataTests = 0
              $totalMetadataPassed = 0
              $totalMetadataFailed = 0
              $totalMetadataSkipped = 0
              $totalMetadataDuration = 0
              
              foreach ($metadataResult in $e2eResults.MetadataTests) {
                  $totalMetadataTests += $metadataResult.TotalCount
                  $totalMetadataPassed += $metadataResult.PassedCount
                  $totalMetadataFailed += $metadataResult.FailedCount
                  $totalMetadataSkipped += $metadataResult.SkippedCount
                  $totalMetadataDuration += $metadataResult.Duration.TotalSeconds
              }
              
              Write-Host "  Total:   $totalMetadataTests" -ForegroundColor White
              Write-Host "  Passed:  $totalMetadataPassed" -ForegroundColor Green
              Write-Host "  Failed:  $totalMetadataFailed" -ForegroundColor $(if ($totalMetadataFailed -gt 0) { "Red" } else { "Green" })
              Write-Host "  Skipped: $totalMetadataSkipped" -ForegroundColor Yellow
              Write-Host "  Duration: $($totalMetadataDuration)s" -ForegroundColor White
              
              if ($totalMetadataFailed -gt 0) {
                  $hasFailures = $true
                  Write-Host ""
                  Write-Host "Failed Metadata E2E Tests:" -ForegroundColor Red
                  foreach ($metadataResult in $e2eResults.MetadataTests) {
                      if ($metadataResult.FailedCount -gt 0) {
                          foreach ($test in $metadataResult.Failed) {
                              Write-Host "  - $($test.ExpandedPath)" -ForegroundColor Red
                              if ($test.ErrorRecord) {
                                  Write-Host "    $($test.ErrorRecord.Exception.Message)" -ForegroundColor Gray
                              }
                          }
                      }
                  }
              }
          }
          
          if ($e2eResults.NonMetadataTests) {
              Write-Host ""
              Write-Host "Non-Metadata E2E Tests (Parallel):"
              
              $totalNonMetadataTests = ($e2eResults.NonMetadataTests | Measure-Object -Property TotalCount -Sum).Sum
              $totalNonMetadataPassed = ($e2eResults.NonMetadataTests | Measure-Object -Property PassedCount -Sum).Sum
              $totalNonMetadataFailed = ($e2eResults.NonMetadataTests | Measure-Object -Property FailedCount -Sum).Sum
              $totalNonMetadataSkipped = ($e2eResults.NonMetadataTests | Measure-Object -Property SkippedCount -Sum).Sum
              $totalNonMetadataDuration = ($e2eResults.NonMetadataTests | Measure-Object -Property DurationSeconds -Sum).Sum
              
              Write-Host "  Total:   $totalNonMetadataTests" -ForegroundColor White
              Write-Host "  Passed:  $totalNonMetadataPassed" -ForegroundColor Green
              Write-Host "  Failed:  $totalNonMetadataFailed" -ForegroundColor $(if ($totalNonMetadataFailed -gt 0) { "Red" } else { "Green" })
              Write-Host "  Skipped: $totalNonMetadataSkipped" -ForegroundColor Yellow
              Write-Host "  Duration: $($totalNonMetadataDuration)s" -ForegroundColor White
              
              if ($totalNonMetadataFailed -gt 0) {
                  $hasFailures = $true
                  Write-Host ""
                  Write-Host "Failed Non-Metadata E2E Tests:" -ForegroundColor Red
                  foreach ($result in $e2eResults.NonMetadataTests | Where-Object { $_.FailedCount -gt 0 }) {
                      Write-Host "  File: $($result.File)" -ForegroundColor Yellow
                      foreach ($test in $result.Failed) {
                          Write-Host "    - $($test.ExpandedPath)" -ForegroundColor Red
                          if ($test.ErrorRecord) {
                              Write-Host "      $($test.ErrorRecord.Exception.Message)" -ForegroundColor Gray
                          }
                      }
                  }
              }
          }
          
          if ($hasFailures) {
              exit 1
          }
          
          Write-Host ""
          Write-Host "All tests passed!" -ForegroundColor Green
      - if:  ${{ matrix.powershell_version == '5' }}
        name: Test - powershell (Standard + E2E in parallel)
        id: test-powershell
        timeout-minutes: 90  # Tests expected to complete in < 90 minutes
        shell: powershell
        env:
          E2ETESTS_URL: ${{ vars.E2ETESTS_URL }}
          E2ETESTS_CLIENTID: ${{ vars.E2ETESTS_CLIENTID }}
          E2ETESTS_CLIENTSECRET: ${{ secrets.E2ETESTS_CLIENTSECRET }}
        run: |  
            $env:TESTMODULEPATH=(resolve-path "out/Rnwood.Dataverse.Data.PowerShell")
  
            Install-Module -Force -Scope CurrentUser -SkipPublisherCheck Pester -MinimumVersion 5.0.0 -MaximumVersion 5.99.99
            
            # Start standard tests and E2E tests in parallel
            
            # Capture current working directory to pass to background jobs
            $workingDir = Get-Location
            
            # Job 1: Standard tests
            $standardTestsJob = Start-Job -ScriptBlock {
                param($modulePath, $workDir)
                
                # Set working directory for this job
                Set-Location $workDir
                
                $env:TESTMODULEPATH = $modulePath
                
                $testFiles = Get-ChildItem 'tests/*.Tests.ps1' -Exclude 'Performance-Investigation.Tests.ps1' | Select-Object -ExpandProperty FullName
                
                # Start a job for each test file
                $jobs = $testFiles | ForEach-Object {
                    $testFile = $_
                    Start-Job -ScriptBlock {
                        param($testFilePath, $modulePath)
                        
                        $env:TESTMODULEPATH = $modulePath
                        
                        # Run each test file independently
                        $config = New-PesterConfiguration
                        $config.Run.Path = $testFilePath
                        $config.Run.PassThru = $true
                        $config.Output.Verbosity = 'Normal'
                        $config.Should.ErrorAction = 'Continue'
                        
                        $result = Invoke-Pester -Configuration $config
                        
                        # Return result with filename for aggregation
                        [PSCustomObject]@{
                            File = (Split-Path $testFilePath -Leaf)
                            TotalCount = $result.TotalCount
                            PassedCount = $result.PassedCount
                            FailedCount = $result.FailedCount
                            SkippedCount = $result.SkippedCount
                            DurationSeconds = $result.Duration.TotalSeconds
                            Failed = $result.Failed
                        }
                    } -ArgumentList $testFile, $modulePath
                }
                
                # Wait for all test file jobs to complete with streaming output
                while ($jobs | Where-Object { $_.State -eq 'Running' }) {
                    foreach ($job in $jobs) {
                        if ($job.HasMoreData) {
                            $job | Receive-Job
                        }
                    }
                    Start-Sleep -Milliseconds 100
                }
                
                # Get final results
                $results = $jobs | Receive-Job
                $jobs | Remove-Job
                
                return $results
            } -ArgumentList $env:TESTMODULEPATH, $workingDir
            
            # Job 2: E2E tests (Module.Tests.ps1 for PowerShell 5)
            $e2eTestsJob = Start-Job -ScriptBlock {
                param($modulePath, $e2eUrl, $e2eClientId, $e2eClientSecret, $workDir)
                
                # Set working directory for this job
                Set-Location $workDir
                
                $env:TESTMODULEPATH = $modulePath
                $env:E2ETESTS_URL = $e2eUrl
                $env:E2ETESTS_CLIENTID = $e2eClientId
                $env:E2ETESTS_CLIENTSECRET = $e2eClientSecret
                
                $config = New-PesterConfiguration
                $config.Run.Path = 'e2e-tests/Module.Tests.ps1'
                $config.Run.PassThru = $true
                $config.Output.Verbosity = 'Normal'
                $config.Filter.ExcludeTag = 'LongRunning'
                
                $result = Invoke-Pester -Configuration $config
                
                return $result
            } -ArgumentList $env:TESTMODULEPATH, $env:E2ETESTS_URL, $env:E2ETESTS_CLIENTID, $env:E2ETESTS_CLIENTSECRET, $workingDir
            
            # Wait for both jobs to complete and show progress
            # Poll jobs to show streaming output
            while ($standardTestsJob.State -eq 'Running' -or $e2eTestsJob.State -eq 'Running') {
                # Receive any available output without waiting
                if ($standardTestsJob.HasMoreData) {
                    $standardTestsJob | Receive-Job
                }
                if ($e2eTestsJob.HasMoreData) {
                    $e2eTestsJob | Receive-Job
                }
                Start-Sleep -Milliseconds 100
            }
            
            # Get final results
            $standardResults = $standardTestsJob | Receive-Job
            $e2eResult = $e2eTestsJob | Receive-Job
            
            Remove-Job $standardTestsJob, $e2eTestsJob
            
            # Process standard test results
            Write-Host ""
            Write-Host "=== Standard Tests Results ===" -ForegroundColor Cyan
            $totalTests = ($standardResults | Measure-Object -Property TotalCount -Sum).Sum
            $totalPassed = ($standardResults | Measure-Object -Property PassedCount -Sum).Sum
            $totalFailed = ($standardResults | Measure-Object -Property FailedCount -Sum).Sum
            $totalSkipped = ($standardResults | Measure-Object -Property SkippedCount -Sum).Sum
            $totalDurationSeconds = ($standardResults | Measure-Object -Property DurationSeconds -Sum).Sum
            
            Write-Host "  Total:   $totalTests" -ForegroundColor White
            Write-Host "  Passed:  $totalPassed" -ForegroundColor Green
            Write-Host "  Failed:  $totalFailed" -ForegroundColor $(if ($totalFailed -gt 0) { "Red" } else { "Green" })
            Write-Host "  Skipped: $totalSkipped" -ForegroundColor Yellow
            Write-Host "  Duration: $($totalDurationSeconds)s" -ForegroundColor White
            
            $hasFailures = $false
            
            if ($totalFailed -gt 0) {
                $hasFailures = $true
                Write-Host ""
                Write-Host "Failed Standard Tests:" -ForegroundColor Red
                foreach ($result in $standardResults | Where-Object { $_.FailedCount -gt 0 }) {
                    Write-Host "  File: $($result.File)" -ForegroundColor Yellow
                    foreach ($test in $result.Failed) {
                        Write-Host "    - $($test.ExpandedPath)" -ForegroundColor Red
                        if ($test.ErrorRecord) {
                            Write-Host "      $($test.ErrorRecord.Exception.Message)" -ForegroundColor Gray
                        }
                    }
                }
            }
            
            # Process E2E test results
            Write-Host ""
            Write-Host "=== E2E Tests Results ===" -ForegroundColor Cyan
            Write-Host "Module.Tests.ps1:"
            Write-Host "  Total:   $($e2eResult.TotalCount)" -ForegroundColor White
            Write-Host "  Passed:  $($e2eResult.PassedCount)" -ForegroundColor Green
            Write-Host "  Failed:  $($e2eResult.FailedCount)" -ForegroundColor $(if ($e2eResult.FailedCount -gt 0) { "Red" } else { "Green" })
            Write-Host "  Skipped: $($e2eResult.SkippedCount)" -ForegroundColor Yellow
            Write-Host "  Duration: $($e2eResult.Duration.TotalSeconds)s" -ForegroundColor White
            
            if ($e2eResult.FailedCount -gt 0) {
                $hasFailures = $true
                Write-Host ""
                Write-Host "Failed E2E Tests:" -ForegroundColor Red
                foreach ($test in $e2eResult.Failed) {
                    Write-Host "  - $($test.ExpandedPath)" -ForegroundColor Red
                    if ($test.ErrorRecord) {
                        Write-Host "    $($test.ErrorRecord.Exception.Message)" -ForegroundColor Gray
                    }
                }
            }
            
            if ($hasFailures) {
                exit 1
            }
            
            Write-Host ""
            Write-Host "All tests passed!" -ForegroundColor Green
      
      # Upload artifacts needed for publishing
      - name: Upload build artifacts
        uses: actions/upload-artifact@v5
        with:
          name: module-${{ matrix.os }}-${{ matrix.powershell_version }}
          path: |
            out/Rnwood.Dataverse.Data.PowerShell/
            release-notes.md
            release-notes.txt
            ci-version.txt
          if-no-files-found: ignore
          retention-days: 1      
      
      # Upload test failure reports as artifacts
      - name: Upload test failure report
        if: failure() && github.event_name == 'pull_request'
        uses: actions/upload-artifact@v5
        with:
          name: test-failures-${{ matrix.os }}-${{ matrix.powershell_version }}
          path: test-failures-*.md
          if-no-files-found: ignore
      
      # Comment on PR with test failures
      - name: Comment on PR with test failures
        if: failure() && github.event_name == 'pull_request'
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Find failure report file
            const files = fs.readdirSync('.');
            const failureFile = files.find(f => f.startsWith('test-failures-'));
            
            if (!failureFile) {
              console.log('No test failure report found');
              return;
            }
            
            const failureContent = fs.readFileSync(failureFile, 'utf8');
            
            // Create comment body with @copilot mention
            const commentBody = `@copilot please investigate these test failures:

            ${failureContent}

            **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            **Commit:** ${{ github.sha }}
            `;
            
            // Post comment to PR
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });

  # Publish job - runs after all test jobs complete successfully
  publish:
    needs: test
    if: github.event_name == 'release' && github.event.action == 'published'
    runs-on: windows-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
      
      - name: Download build artifacts
        uses: actions/download-artifact@v5
        with:
          name: module-windows-latest-5
          path: .
      
      - name: Publish Release to PowerShell Gallery
        env:
          NUGET_KEY: ${{ secrets.NUGET_KEY }}
        shell: pwsh
        run: |
          # Add release notes to module manifest
          $manifestPath = "out/Rnwood.Dataverse.Data.PowerShell/Rnwood.Dataverse.Data.PowerShell.psd1"
          $releaseNotes = Get-Content -Path "release-notes.txt" -Raw
          
          $content = Get-Content -Path $manifestPath -Raw
          
          # Add or update ReleaseNotes in PrivateData.PSData
          if ($content -match "ReleaseNotes\s*=") {
            # ReleaseNotes already exists, replace it
            $content = $content -replace "ReleaseNotes\s*=\s*'[^']*'", "ReleaseNotes = '$($releaseNotes -replace "'", "''")'"
            $content = $content -replace 'ReleaseNotes\s*=\s*"[^"]*"', "ReleaseNotes = '$($releaseNotes -replace "'", "''")'"
          } else {
            # Add ReleaseNotes to PSData section
            if ($content -match "PSData\s*=\s*@\{") {
              $content = $content -replace "(PSData\s*=\s*@\{)", "`$1`n`t`tReleaseNotes = '$($releaseNotes -replace "'", "''")';"
            }
          }
          
          $content | Set-Content -Path $manifestPath -Encoding UTF8
          
          # Publish stable release to PowerShell Gallery
          Publish-Module -Path out/Rnwood.Dataverse.Data.PowerShell -NuGetApiKey $env:NUGET_KEY -Verbose
      
      - name: Update GitHub Release Description
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            
            // Get the current release
            const release = context.payload.release;
            const version = release.tag_name.replace(/^v/, '');
            
            // Read existing release notes
            const releaseNotes = fs.readFileSync('release-notes.md', 'utf8');
            
            // Build enhanced release body with PowerShell Gallery and installation links
            const galleryUrl = `https://www.powershellgallery.com/packages/Rnwood.Dataverse.Data.PowerShell/${version}`;
            const installDocsUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/docs/getting-started/installation.md`;
            const readmeUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}#installation`;
            
            // Preserve any existing body text
            const existingBody = release.body || '';
            
            // Build enhanced release body
            let enhancedBody = '## ðŸ“¦ Installation\n\n';
            enhancedBody += `View this release on PowerShell Gallery: [${version}](${galleryUrl})\n\n`;
            enhancedBody += 'To install this release:\n';
            enhancedBody += '```powershell\n';
            enhancedBody += `Install-Module Rnwood.Dataverse.Data.PowerShell -RequiredVersion ${version} -Scope CurrentUser\n`;
            enhancedBody += '```\n\n';
            enhancedBody += 'For more installation options, see:\n';
            enhancedBody += `- [Installation Guide](${installDocsUrl})\n`;
            enhancedBody += `- [Quick Start in README](${readmeUrl})\n\n`;
            enhancedBody += '## Changes\n\n';
            enhancedBody += releaseNotes;
            if (existingBody) {
              enhancedBody += '\n\n---\n\n' + existingBody;
            }
            
            // Update the release
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.id,
              body: enhancedBody
            });
  
  # CI Build Publishing (main branch only)
  publish-ci:
    needs: test
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: windows-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
      
      - name: Download build artifacts
        uses: actions/download-artifact@v5
        with:
          name: module-windows-latest-5
          path: .
      
      - name: Create CI Build Artifact
        shell: pwsh
        run: |
          # Create a zip file of the module
          Compress-Archive -Path out/Rnwood.Dataverse.Data.PowerShell -DestinationPath Rnwood.Dataverse.Data.PowerShell-CI.zip -Force
      
      - name: Create GitHub Release for CI Build
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const version = fs.readFileSync('ci-version.txt', 'utf8').trim();
            const shortSha = context.sha.substring(0, 7);
            const tagName = `v${version}`;
            
            // Check if release with this tag already exists
            try {
              const existingRelease = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });
              
              // If found, delete it (also deletes the tag if it was created by the release)
              console.log(`Deleting existing release: ${tagName}`);
              await github.rest.repos.deleteRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: existingRelease.data.id
              });
              
              // Also delete the tag explicitly in case it still exists
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${tagName}`
                });
                console.log(`Deleted existing tag: ${tagName}`);
              } catch (error) {
                // Tag might not exist or already deleted, ignore
                console.log(`Tag ${tagName} not found or already deleted`);
              }
            } catch (error) {
              // Release doesn't exist, which is fine
              console.log(`No existing release found for ${tagName}`);
            }
            
            // Read release notes
            const releaseNotes = fs.readFileSync('release-notes.md', 'utf8');
            
            // Build release body with PowerShell Gallery and installation links
            const galleryUrl = `https://www.powershellgallery.com/packages/Rnwood.Dataverse.Data.PowerShell/${version}`;
            const installDocsUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/docs/getting-started/installation.md`;
            const readmeUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}#installation`;
            
            let releaseBody = `Automated CI build from commit ${shortSha}\n\n`;
            releaseBody += '**This is a prerelease version for testing purposes.**\n\n';
            releaseBody += '## ðŸ“¦ Installation\n\n';
            releaseBody += `View this prerelease on PowerShell Gallery: [${version}](${galleryUrl})\n\n`;
            releaseBody += 'To install this CI build:\n';
            releaseBody += '```powershell\n';
            releaseBody += `Install-Module Rnwood.Dataverse.Data.PowerShell -RequiredVersion ${version} -AllowPrerelease -Scope CurrentUser\n`;
            releaseBody += '```\n\n';
            releaseBody += 'For more installation options, see:\n';
            releaseBody += `- [Installation Guide](${installDocsUrl})\n`;
            releaseBody += `- [Quick Start in README](${readmeUrl})\n\n`;
            releaseBody += '## Changes\n\n';
            releaseBody += releaseNotes;
            releaseBody += '\n\n---\n';
            releaseBody += `**Commit:** ${context.sha}\n`;
            releaseBody += '**Branch:** main';
            
            // Create prerelease with release notes
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: `CI Build ${version}`,
              body: releaseBody,
              draft: false,
              prerelease: true,
              target_commitish: context.sha
            });
            
            // Upload the zip artifact
            const assetData = fs.readFileSync('Rnwood.Dataverse.Data.PowerShell-CI.zip');
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.data.id,
              name: 'Rnwood.Dataverse.Data.PowerShell-CI.zip',
              data: assetData
            });
      
      - name: Publish CI Build to PowerShell Gallery
        env:
          NUGET_KEY: ${{ secrets.NUGET_KEY }}
        shell: pwsh
        run: |
          # Add release notes to module manifest
          $manifestPath = "out/Rnwood.Dataverse.Data.PowerShell/Rnwood.Dataverse.Data.PowerShell.psd1"
          $releaseNotes = Get-Content -Path "release-notes.txt" -Raw
          
          $content = Get-Content -Path $manifestPath -Raw
          
          # Add or update ReleaseNotes in PrivateData.PSData
          if ($content -match "ReleaseNotes\s*=") {
            # ReleaseNotes already exists, replace it
            $content = $content -replace "ReleaseNotes\s*=\s*'[^']*'", "ReleaseNotes = '$($releaseNotes -replace "'", "''")'"
            $content = $content -replace 'ReleaseNotes\s*=\s*"[^"]*"', "ReleaseNotes = '$($releaseNotes -replace "'", "''")'"
          } else {
            # Add ReleaseNotes to PSData section
            if ($content -match "PSData\s*=\s*@\{") {
              $content = $content -replace "(PSData\s*=\s*@\{)", "`$1`n`t`tReleaseNotes = '$($releaseNotes -replace "'", "''")';"
            }
          }
          
          $content | Set-Content -Path $manifestPath -Encoding UTF8
          
          # Publish prerelease to PowerShell Gallery
          Publish-Module -Path out/Rnwood.Dataverse.Data.PowerShell -NuGetApiKey $env:NUGET_KEY -Verbose
