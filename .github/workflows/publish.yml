name: Build / publish

on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, reopened, synchronize]
  release:
    types: [published]

jobs:
  main:
    permissions:
      contents: write  # Required for creating GitHub releases
      pull-requests: write
    timeout-minutes: 60  # Fail fast if job exceeds 60 minutes
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            publish: false
            powershell_version: "7.4.11"
          - os: windows-latest
            publish: false
            powershell_version: "7.4.11"
          - os: ubuntu-latest
            publish: false
            powershell_version: latest
          - os: windows-latest
            publish: false
            powershell_version: latest
          - os: windows-latest
            publish: true
            powershell_version: '5'

    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0  # Fetch all history for tags
      - if: ${{ matrix.powershell_version != '5' }}
        name: Install PowerShell ${{ matrix.powershell_version }}
        uses: PSModule/install-powershell@v1
        with:
          Version: ${{ matrix.powershell_version }}
      - name: Build
        shell: pwsh
        run: |       
          $manifestpath = "Rnwood.Dataverse.Data.PowerShell/Rnwood.Dataverse.Data.PowerShell.psd1"
          
          if ($env:GITHUB_REF -like "refs/tags/*") {
            # Release build - use tag version
            $versionnumber = $env:GITHUB_REF -replace "refs/tags/", ""
            (get-content -raw -encoding UTF8 $manifestpath ) -replace "ModuleVersion ?=.*", "ModuleVersion = `"$versionnumber`"" | set-content -encoding UTF8 $manifestpath
            Write-Host "Release version: $versionnumber"
          } elseif ($env:GITHUB_REF -eq "refs/heads/main") {
            # CI build on main branch - auto-determine version with date-based -ci suffix
            $latestTag = git describe --tags --abbrev=0 2>$null
            if (-not $latestTag) {
              $latestTag = "0.0.0"
            }
            
            # Parse version from tag
            if ($latestTag -match '^v?(\d+\.\d+\.\d+)') {
              $baseVersion = $matches[1]
            } else {
              $baseVersion = "0.0.0"
            }
            
            # Get current date in yyyyMMdd format (UTC)
            $nowUtc = [DateTime]::UtcNow
            $dateString = $nowUtc.ToString("yyyyMMdd")
            
            # Use GitHub Actions run number as sequence number for better reliability
            # GITHUB_RUN_NUMBER is a sequential number that increments with each workflow run
            # Falls back to 1 if not in GitHub Actions environment
            $runNumber = $env:GITHUB_RUN_NUMBER
            if (-not $runNumber) {
              $runNumber = 1
            }
            
            # Build CI version with date-based prerelease suffix: ci<yyyyMMdd><seqNum>
            # where seqNum is zero-padded to 3 digits for SemVer 1.0 compliance (no dots allowed)
            $seqNum = "{0:000}" -f [int]$runNumber
            $prereleaseString = "ci$dateString$seqNum"
            
            # Update manifest with base version and prerelease in one operation
            $content = get-content -raw -encoding UTF8 $manifestpath
            
            # Update ModuleVersion
            $content = $content -replace "ModuleVersion ?=.*", "ModuleVersion = `"$baseVersion`""
            
            # Add prerelease to PrivateData.PSData if not already present
            if ($content -notmatch "Prerelease\s*=") {
              if ($content -match "PrivateData\s*=\s*@\{") {
                if ($content -match "PSData\s*=\s*@\{") {
                  # PSData section exists - add Prerelease field
                  $content = $content -replace "(PSData\s*=\s*@\{)", "`$1`n`t`tPrerelease = '-$prereleaseString'"
                } else {
                  # Add PSData section with Prerelease
                  $content = $content -replace "(PrivateData\s*=\s*@\{)", "`$1`n`tPSData = @{`n`t`tPrerelease = '-$prereleaseString'`n`t}"
                }
              }
            }
            
            # Write updated content once
            $content | set-content -encoding UTF8 $manifestpath
            
            Write-Host "CI version: $baseVersion-$prereleaseString"
            # Save version for later steps
            "$baseVersion-$prereleaseString" | Out-File -FilePath ci-version.txt -Encoding utf8
          }

          dotnet build -c Release ./Rnwood.Dataverse.Data.PowerShell/Rnwood.Dataverse.Data.PowerShell.csproj
          if (test-path out/Rnwood.Dataverse.Data.PowerShell) {
            remove-item -force -recurse out/Rnwood.Dataverse.Data.PowerShell
          }
          copy-item -recurse Rnwood.Dataverse.Data.PowerShell\bin\Release\netstandard2.0 out/Rnwood.Dataverse.Data.PowerShell
      - if: ${{ matrix.powershell_version != '5' }}
        name: Test - pwsh
        id: test-pwsh
        timeout-minutes: 45  # Tests expected to complete in < 45 minutes
        shell: pwsh
        run: |
          Write-Host "Using PowerShell $($PSVersionTable.PSVersion)"    
          $env:TESTMODULEPATH=(resolve-path "out/Rnwood.Dataverse.Data.PowerShell")

          Install-Module -Force -Scope CurrentUser -SkipPublisherCheck Pester -MinimumVersion 5.0.0 -MaximumVersion 5.99.99
          
          # Run tests with CI-friendly output
          # Each test file now includes Common.ps1 for setup, allowing Pester to run them independently
          # Run test files in parallel using Start-Job for maximum performance
          
          Write-Host "Discovering test files..."
          $testFiles = Get-ChildItem 'tests/*.Tests.ps1' -Exclude 'Performance-Investigation.Tests.ps1' | Select-Object -ExpandProperty FullName
          Write-Host "Found $($testFiles.Count) test files to run in parallel"
          
          # Start a job for each test file
          $jobs = $testFiles | ForEach-Object {
              $testFile = $_
              Start-Job -ScriptBlock {
                  param($testFilePath, $modulePath)
                  
                  $env:TESTMODULEPATH = $modulePath
                  
                  # Run each test file independently
                  $config = New-PesterConfiguration
                  $config.Run.Path = $testFilePath
                  $config.Run.PassThru = $true
                  $config.Output.Verbosity = 'None'  # Suppress individual file output to avoid clutter
                  $config.Should.ErrorAction = 'Continue'
                  
                  $result = Invoke-Pester -Configuration $config
                  
                  # Return result with filename for aggregation
                  [PSCustomObject]@{
                      File = (Split-Path $testFilePath -Leaf)
                      TotalCount = $result.TotalCount
                      PassedCount = $result.PassedCount
                      FailedCount = $result.FailedCount
                      SkippedCount = $result.SkippedCount
                      DurationSeconds = $result.Duration.TotalSeconds
                      Failed = $result.Failed
                  }
              } -ArgumentList $testFile, $env:TESTMODULEPATH
          }
          
          Write-Host "Running $($jobs.Count) test files in parallel..."
          
          # Wait for all jobs to complete and collect results
          $results = $jobs | Wait-Job | Receive-Job
          $jobs | Remove-Job
          
          # Aggregate results
          $totalTests = ($results | Measure-Object -Property TotalCount -Sum).Sum
          $totalPassed = ($results | Measure-Object -Property PassedCount -Sum).Sum
          $totalFailed = ($results | Measure-Object -Property FailedCount -Sum).Sum
          $totalSkipped = ($results | Measure-Object -Property SkippedCount -Sum).Sum
          $totalDurationSeconds = ($results | Measure-Object -Property DurationSeconds -Sum).Sum
          
          Write-Host ""
          Write-Host "Parallel Test Execution Summary:" -ForegroundColor Cyan
          Write-Host "  Total:   $totalTests" -ForegroundColor White
          Write-Host "  Passed:  $totalPassed" -ForegroundColor Green
          Write-Host "  Failed:  $totalFailed" -ForegroundColor $(if ($totalFailed -gt 0) { "Red" } else { "Green" })
          Write-Host "  Skipped: $totalSkipped" -ForegroundColor Yellow
          Write-Host "  Duration: $($totalDurationSeconds)s" -ForegroundColor White
          
          # Report failures if any
          if ($totalFailed -gt 0) {
              Write-Host ""
              Write-Host "Failed Tests:" -ForegroundColor Red
              foreach ($result in $results | Where-Object { $_.FailedCount -gt 0 }) {
                  Write-Host "  File: $($result.File)" -ForegroundColor Yellow
                  foreach ($test in $result.Failed) {
                      Write-Host "    - $($test.ExpandedPath)" -ForegroundColor Red
                      if ($test.ErrorRecord) {
                          Write-Host "      $($test.ErrorRecord.Exception.Message)" -ForegroundColor Gray
                      }
                  }
              }
              exit 1
          }
      - if:  ${{ matrix.powershell_version == '5' }}
        name: Test - powershell
        id: test-powershell
        timeout-minutes: 45  # Tests expected to complete in < 45 minutes
        shell: powershell
        run: |  
            $env:TESTMODULEPATH=(resolve-path "out/Rnwood.Dataverse.Data.PowerShell")
  
            Install-Module -Force -Scope CurrentUser -SkipPublisherCheck Pester -MinimumVersion 5.0.0 -MaximumVersion 5.99.99
            
            # Run tests with CI-friendly output
            # Each test file now includes Common.ps1 for setup, allowing Pester to run them independently
            # Run test files in parallel using Start-Job for maximum performance
            
            Write-Host "Discovering test files..."
            $testFiles = Get-ChildItem 'tests/*.Tests.ps1' -Exclude 'Performance-Investigation.Tests.ps1' | Select-Object -ExpandProperty FullName
            Write-Host "Found $($testFiles.Count) test files to run in parallel"
            
            # Start a job for each test file
            $jobs = $testFiles | ForEach-Object {
                $testFile = $_
                Start-Job -ScriptBlock {
                    param($testFilePath, $modulePath)
                    
                    $env:TESTMODULEPATH = $modulePath
                    
                    # Run each test file independently
                    $config = New-PesterConfiguration
                    $config.Run.Path = $testFilePath
                    $config.Run.PassThru = $true
                    $config.Output.Verbosity = 'None'  # Suppress individual file output to avoid clutter
                    $config.Should.ErrorAction = 'Continue'
                    
                    $result = Invoke-Pester -Configuration $config
                    
                    # Return result with filename for aggregation
                    [PSCustomObject]@{
                        File = (Split-Path $testFilePath -Leaf)
                        TotalCount = $result.TotalCount
                        PassedCount = $result.PassedCount
                        FailedCount = $result.FailedCount
                        SkippedCount = $result.SkippedCount
                        DurationSeconds = $result.Duration.TotalSeconds
                        Failed = $result.Failed
                    }
                } -ArgumentList $testFile, $env:TESTMODULEPATH
            }
            
            Write-Host "Running $($jobs.Count) test files in parallel..."
            
            # Wait for all jobs to complete and collect results
            $results = $jobs | Wait-Job | Receive-Job
            $jobs | Remove-Job
            
            # Aggregate results
            $totalTests = ($results | Measure-Object -Property TotalCount -Sum).Sum
            $totalPassed = ($results | Measure-Object -Property PassedCount -Sum).Sum
            $totalFailed = ($results | Measure-Object -Property FailedCount -Sum).Sum
            $totalSkipped = ($results | Measure-Object -Property SkippedCount -Sum).Sum
            $totalDurationSeconds = ($results | Measure-Object -Property DurationSeconds -Sum).Sum
            
            Write-Host ""
            Write-Host "Parallel Test Execution Summary:" -ForegroundColor Cyan
            Write-Host "  Total:   $totalTests" -ForegroundColor White
            Write-Host "  Passed:  $totalPassed" -ForegroundColor Green
            Write-Host "  Failed:  $totalFailed" -ForegroundColor $(if ($totalFailed -gt 0) { "Red" } else { "Green" })
            Write-Host "  Skipped: $totalSkipped" -ForegroundColor Yellow
            Write-Host "  Duration: $($totalDurationSeconds)s" -ForegroundColor White
            
            # Report failures if any
            if ($totalFailed -gt 0) {
                Write-Host ""
                Write-Host "Failed Tests:" -ForegroundColor Red
                foreach ($result in $results | Where-Object { $_.FailedCount -gt 0 }) {
                    Write-Host "  File: $($result.File)" -ForegroundColor Yellow
                    foreach ($test in $result.Failed) {
                        Write-Host "    - $($test.ExpandedPath)" -ForegroundColor Red
                        if ($test.ErrorRecord) {
                            Write-Host "      $($test.ErrorRecord.Exception.Message)" -ForegroundColor Gray
                        }
                    }
                }
                exit 1
            }
      - if: ${{ matrix.powershell_version != '5' }}
        name: E2E Test - pwsh
        shell: pwsh
        env:
          E2ETESTS_URL: ${{ vars.E2ETESTS_URL }}
          E2ETESTS_CLIENTID: ${{ vars.E2ETESTS_CLIENTID }}
          E2ETESTS_CLIENTSECRET: ${{ secrets.E2ETESTS_CLIENTSECRET }}
        run: |  
          Write-Host "Using PowerShell $($PSVersionTable.PSVersion)"
          $env:TESTMODULEPATH=(resolve-path "out/Rnwood.Dataverse.Data.PowerShell")

          Install-Module -Force -Scope CurrentUser -SkipPublisherCheck Pester -MinimumVersion 5.0.0 -MaximumVersion 5.99.99
          
          # Run e2e tests excluding long-running tests
          $config = New-PesterConfiguration
          $config.Run.Path = 'e2e-tests'
          $config.Run.PassThru = $true
          $config.Output.Verbosity = 'Detailed'
          $config.Filter.ExcludeTag = 'LongRunning'
          
          $result = Invoke-Pester -Configuration $config
          
          if ($result.FailedCount -gt 0) {
            throw "Tests failed"
          }
      - if:  ${{ matrix.powershell_version == '5' }}
        name: E2E Test - powershell
        shell: powershell
        env:
          E2ETESTS_URL: ${{ vars.E2ETESTS_URL }}
          E2ETESTS_CLIENTID: ${{ vars.E2ETESTS_CLIENTID }}
          E2ETESTS_CLIENTSECRET: ${{ secrets.E2ETESTS_CLIENTSECRET }}
        run: |  
          $env:TESTMODULEPATH=(resolve-path "out/Rnwood.Dataverse.Data.PowerShell")

          Install-Module -Force -Scope CurrentUser -SkipPublisherCheck Pester -MinimumVersion 5.0.0 -MaximumVersion 5.99.99
          
          # Run e2e tests excluding long-running tests
          $config = New-PesterConfiguration
          $config.Run.Path = 'e2e-tests'
          $config.Run.PassThru = $true
          $config.Output.Verbosity = 'Detailed'
          $config.Filter.ExcludeTag = 'LongRunning'
          
          $result = Invoke-Pester -Configuration $config
          
          if ($result.FailedCount -gt 0) {
            throw "Tests failed"
          }      
      - if: ${{ matrix.publish && github.event_name == 'release' && github.event.action == 'published' }}
        name: Publish Release to PowerShell Gallery
        env:
          NUGET_KEY: ${{ secrets.NUGET_KEY }}
        shell: pwsh
        run: |
          Publish-Module -Path out/Rnwood.Dataverse.Data.PowerShell -NuGetApiKey $env:NUGET_KEY -Verbose
      
      # CI Build Publishing (main branch only)
      - if: ${{ matrix.publish && github.ref == 'refs/heads/main' && github.event_name == 'push' }}
        name: Create CI Build Artifact
        shell: pwsh
        run: |
          # Create a zip file of the module
          Compress-Archive -Path out/Rnwood.Dataverse.Data.PowerShell -DestinationPath Rnwood.Dataverse.Data.PowerShell-CI.zip -Force
      
      - if: ${{ matrix.publish && github.ref == 'refs/heads/main' && github.event_name == 'push' }}
        name: Create GitHub Release for CI Build
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const version = fs.readFileSync('ci-version.txt', 'utf8').trim();
            const shortSha = context.sha.substring(0, 7);
            const tagName = `v${version}`;
            
            // Check if release with this tag already exists
            try {
              const existingRelease = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });
              
              // If found, delete it (also deletes the tag if it was created by the release)
              console.log(`Deleting existing release: ${tagName}`);
              await github.rest.repos.deleteRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: existingRelease.data.id
              });
              
              // Also delete the tag explicitly in case it still exists
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${tagName}`
                });
                console.log(`Deleted existing tag: ${tagName}`);
              } catch (error) {
                // Tag might not exist or already deleted, ignore
                console.log(`Tag ${tagName} not found or already deleted`);
              }
            } catch (error) {
              // Release doesn't exist, which is fine
              console.log(`No existing release found for ${tagName}`);
            }
            
            // Create prerelease
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: `CI Build ${version}`,
              body: `Automated CI build from commit ${shortSha}\n\n**This is a prerelease version for testing purposes.**\n\nCommit: ${context.sha}\nBranch: main`,
              draft: false,
              prerelease: true,
              target_commitish: context.sha
            });
            
            // Upload the zip artifact
            const assetData = fs.readFileSync('Rnwood.Dataverse.Data.PowerShell-CI.zip');
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.data.id,
              name: 'Rnwood.Dataverse.Data.PowerShell-CI.zip',
              data: assetData
            });
      
      - if: ${{ matrix.publish && github.ref == 'refs/heads/main' && github.event_name == 'push' }}
        name: Publish CI Build to PowerShell Gallery
        env:
          NUGET_KEY: ${{ secrets.NUGET_KEY }}
        shell: pwsh
        run: |
          # Publish prerelease to PowerShell Gallery
          Publish-Module -Path out/Rnwood.Dataverse.Data.PowerShell -NuGetApiKey $env:NUGET_KEY -Verbose
      
      # Upload test failure reports as artifacts
      - name: Upload test failure report
        if: failure() && github.event_name == 'pull_request'
        uses: actions/upload-artifact@v5
        with:
          name: test-failures-${{ matrix.os }}-${{ matrix.powershell_version }}
          path: test-failures-*.md
          if-no-files-found: ignore
      
      # Comment on PR with test failures
      - name: Comment on PR with test failures
        if: failure() && github.event_name == 'pull_request'
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Find failure report file
            const files = fs.readdirSync('.');
            const failureFile = files.find(f => f.startsWith('test-failures-'));
            
            if (!failureFile) {
              console.log('No test failure report found');
              return;
            }
            
            const failureContent = fs.readFileSync(failureFile, 'utf8');
            
            // Create comment body with @copilot mention
            const commentBody = `@copilot please investigate these test failures:

            ${failureContent}

            **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            **Commit:** ${{ github.sha }}
            `;
            
            // Post comment to PR
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });
