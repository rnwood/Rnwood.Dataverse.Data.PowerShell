# SV004: Unauthorized Dependency

## Rule Description

Solution components should only depend on components from authorized solutions or publishers. This ensures that dependencies are intentional and reduces the risk of circular dependencies.

## Severity

**Error** - This issue should be fixed before deploying the solution.

## Why This Matters

Uncontrolled dependencies between solutions can cause several critical problems:

### 1. Unintentional Dependencies
Without validation, components can accidentally reference other solutions' components, creating:
- Hidden coupling between solutions
- Unexpected deployment failures when dependent solutions aren't present
- Difficult-to-diagnose issues when dependent solutions change

### 2. Circular Dependencies
When Solution A depends on Solution B, and Solution B depends on Solution A:
- Neither solution can be installed independently
- Updates become extremely complex
- Deployment order becomes impossible to determine
- Solutions may fail to import entirely

### 3. Solution Bloat
Uncontrolled dependencies lead to:
- Solutions pulling in unnecessary components
- Increased solution size and complexity
- Longer deployment times
- More difficult troubleshooting

### 4. Maintenance Nightmares
As solutions evolve:
- Accidental dependencies make refactoring difficult
- Breaking changes in one solution unexpectedly break others
- Teams lose track of which solutions depend on each other
- Solution boundaries become blurred

## How This Rule Works

This rule is **opt-in** and only runs when you specify allowed dependencies via parameters:

- `-AllowedDependencySolutions`: List of solution name patterns (supports wildcards)
- `-AllowedDependencyPublishers`: List of publisher unique name patterns (supports wildcards)

The rule:
1. Examines all components in your solution
2. Queries their dependencies (required components)
3. Determines which solution/publisher owns each dependency
4. Flags any dependencies not matching your allowed patterns

## Configuration

### Allow Specific Solutions

```powershell
Test-DataverseSolution -UniqueName "MySolution" `
    -AllowedDependencySolutions @("Default", "MyCoreSolution", "MyPlatform*") `
    -Verbose
```

This allows dependencies on:
- The "Default" solution (system components)
- "MyCoreSolution" (exact match)
- Any solution starting with "MyPlatform" (e.g., "MyPlatformCore", "MyPlatformShared")

### Allow Specific Publishers

```powershell
Test-DataverseSolution -UniqueName "MySolution" `
    -AllowedDependencyPublishers @("MicrosoftCorporation", "myorg*") `
    -Verbose
```

This allows dependencies on components from:
- The "MicrosoftCorporation" publisher (standard Dynamics components)
- Any publisher starting with "myorg" (e.g., "myorg", "myorgplatform")

### Combined Approach

```powershell
Test-DataverseSolution -UniqueName "MySolution" `
    -AllowedDependencySolutions @("Default", "Active") `
    -AllowedDependencyPublishers @("MicrosoftCorporation", "mycompany*") `
    -Verbose
```

A dependency is authorized if it matches **either** a solution pattern **or** a publisher pattern.

## Wildcard Patterns

The rule supports standard wildcards:
- `*` matches zero or more characters
- `?` matches exactly one character

**Examples:**
- `MyCore*` matches "MyCore", "MyCoreUtils", "MyCoreV2"
- `My?Core` matches "My1Core", "MyXCore" but not "MyCore" or "My12Core"
- `*Platform*` matches "MyPlatform", "SharedPlatformCore", "PlatformUtils"

## Best Practices

### 1. Start with Broad Patterns, Then Refine

Begin with publisher-based rules to allow all internal solutions:
```powershell
-AllowedDependencyPublishers @("mycompany*")
```

Then gradually tighten by specifying exact solutions as your architecture matures.

### 2. Always Allow System Components

Include patterns for Dynamics/Power Platform system components:
```powershell
-AllowedDependencySolutions @("Default", "Active") `
-AllowedDependencyPublishers @("MicrosoftCorporation")
```

### 3. Integrate with CI/CD

Add dependency validation to your build pipeline:
```powershell
$results = Test-DataverseSolution -UniqueName $solutionName `
    -AllowedDependencySolutions @("Default", "MyPlatform*") `
    -AllowedDependencyPublishers @("MicrosoftCorporation", "myorg") `
    -FailOnSeverity Error `
    -ErrorAction Stop

if ($results.ErrorCount -gt 0) {
    throw "Unauthorized dependencies detected!"
}
```

### 4. Use Severity Overrides for Migration

When refactoring existing solutions with unauthorized dependencies:
```powershell
Test-DataverseSolution -UniqueName "LegacySolution" `
    -AllowedDependencySolutions @("CorePlatform") `
    -OverrideSeverity @("SV004:Warning") `
    -Verbose
```

This downgrades SV004 violations to warnings.

## See Also

- [SV001: Managed Table Include Subcomponents](SV001.md)
- [SV002: Managed Non-Table Not Customized](SV002.md)
- [SV003: Managed Subcomponent Not Customized](SV003.md)
