using System.Globalization;
using System.IO.Compression;
using System.Net.Http.Headers;
using System.Reflection;
using System.Text.Encodings.Web;
using System.Text.RegularExpressions;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Xml.Linq;
using Azure.Core;
using Azure.Identity;
using YamlDotNet.Serialization;

namespace MsAppToolkit;

public static class YamlFirstPackaging
{
    public sealed record EmbeddedTemplateSummary(string Name, string Version, string TemplateId, string YamlControlName, bool RequiresVariantKeyword, IReadOnlyList<string> AvailableVariants, IReadOnlyList<TemplateAppFlagRequirement> AppFlagRequirements);
    public sealed record EmbeddedTemplateProperty(string PropertyName, string? DefaultValue);
    public sealed record EmbeddedTemplateDetails(string Name, string Version, string TemplateId, string YamlControlName, IReadOnlyList<EmbeddedTemplateProperty> Properties, bool RequiresVariantKeyword, IReadOnlyList<string> AvailableVariants, IReadOnlyList<string> CompatibilityNotes, IReadOnlyList<TemplateAppFlagRequirement> AppFlagRequirements);
    /// <summary>Describes an AppPreviewFlagsMap requirement for a template (e.g. classiccontrols must be true).</summary>
    public sealed record TemplateAppFlagRequirement(string FlagName, bool RequiredValue, string Reason);

    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        WriteIndented = true,
        Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping,
    };

    private static readonly HttpClient DataverseHttpClient = new();
    private const string RemovedDataSourcesCacheFileName = ".removed-datasources.cache.json";

    public static IReadOnlyList<EmbeddedTemplateSummary> ListEmbeddedControlTemplates()
    {
        ReadEmbeddedAllControlsEntries(out var embeddedEntries);
        var templates = ReadUsedTemplates(embeddedEntries);
        var variantMap = CollectVariantsByTemplateName(embeddedEntries);

        return templates
            .Select(t =>
            {
                var requiresVariant = RequiresVariantKeyword(t.Name, t.Id, t.TemplateXml, variantMap);
                var variants = MergeVariants(t.Name, t.Id, t.TemplateXml, variantMap);
                var flagReqs = BuildAppFlagRequirements(t.TemplateXml);
                return new EmbeddedTemplateSummary(t.Name, t.Version, t.Id, ToYamlControlName(t.Name), requiresVariant, variants, flagReqs);
            })
            .OrderBy(t => t.Name, StringComparer.OrdinalIgnoreCase)
            .ThenBy(t => t.Version, StringComparer.OrdinalIgnoreCase)
            .ToList();
    }

    public static EmbeddedTemplateDetails DescribeEmbeddedTemplate(string templateName, string? templateVersion = null)
    {
        if (string.IsNullOrWhiteSpace(templateName))
        {
            throw new ArgumentException("Template name must be provided.", nameof(templateName));
        }

        ReadEmbeddedAllControlsEntries(out var embeddedEntries);
        var templates = ReadUsedTemplates(embeddedEntries);

        var matchingByName = templates
            .Where(t => string.Equals(t.Name, templateName, StringComparison.OrdinalIgnoreCase))
            .ToList();

        if (matchingByName.Count == 0)
        {
            throw new InvalidDataException($"Template '{templateName}' was not found in embedded all-controls templates.");
        }

        UsedTemplate selected;
        if (!string.IsNullOrWhiteSpace(templateVersion))
        {
            selected = matchingByName.FirstOrDefault(t => string.Equals(t.Version, templateVersion, StringComparison.OrdinalIgnoreCase));
            if (string.IsNullOrWhiteSpace(selected.Name))
            {
                throw new InvalidDataException($"Template '{templateName}' with version '{templateVersion}' was not found in embedded all-controls templates.");
            }
        }
        else
        {
            selected = matchingByName
                .OrderByDescending(t => SemverTuple(t.Version))
                .First();
        }

        var properties = ParseTemplateProperties(selected.TemplateXml)
            .OrderBy(p => p.PropertyName, StringComparer.OrdinalIgnoreCase)
            .ToList();

        var variantMap = CollectVariantsByTemplateName(embeddedEntries);
        var requiresVariant = RequiresVariantKeyword(selected.Name, selected.Id, selected.TemplateXml, variantMap);
        var variants = MergeVariants(selected.Name, selected.Id, selected.TemplateXml, variantMap);
        var notes = GetCompatibilityNotes(selected.Name, selected.Version);
        var flagReqs = BuildAppFlagRequirements(selected.TemplateXml);

        return new EmbeddedTemplateDetails(selected.Name, selected.Version, selected.Id, ToYamlControlName(selected.Name), properties, requiresVariant, variants, notes, flagReqs);
    }

    public static void GenerateCollectionDataSourceFromJson(string unpackDirectory, string collectionName, string jsonExamplePath)
    {
        if (string.IsNullOrWhiteSpace(unpackDirectory) || !Directory.Exists(unpackDirectory))
        {
            throw new DirectoryNotFoundException($"Unpack directory not found: '{unpackDirectory}'.");
        }

        if (string.IsNullOrWhiteSpace(collectionName))
        {
            throw new ArgumentException("Collection name must be provided.", nameof(collectionName));
        }

        if (string.IsNullOrWhiteSpace(jsonExamplePath) || !File.Exists(jsonExamplePath))
        {
            throw new FileNotFoundException($"JSON example file was not found: '{jsonExamplePath}'.", jsonExamplePath);
        }

        var jsonText = File.ReadAllText(jsonExamplePath);
        JsonNode? parsed;
        try
        {
            parsed = JsonNode.Parse(jsonText);
        }
        catch (Exception ex)
        {
            throw new InvalidDataException($"JSON example file is invalid: {jsonExamplePath}", ex);
        }

        var sampleArray = parsed switch
        {
            JsonArray arr => arr,
            JsonObject obj => new JsonArray(obj.DeepClone()),
            _ => throw new InvalidDataException("JSON example must be a JSON object or array of objects."),
        };

        var columns = InferColumns(sampleArray);
        var schema = BuildSchema(columns);

        var dataSourcesPath = Path.Combine(unpackDirectory, "References", "DataSources.json");
        Directory.CreateDirectory(Path.GetDirectoryName(dataSourcesPath)!);

        JsonObject root;
        JsonArray dataSources;
        if (File.Exists(dataSourcesPath)
            && JsonNode.Parse(File.ReadAllText(dataSourcesPath)) is JsonObject existingRoot
            && existingRoot["DataSources"] is JsonArray existingArray)
        {
            root = existingRoot;
            dataSources = existingArray;
        }
        else
        {
            root = new JsonObject();
            dataSources = new JsonArray();
            root["DataSources"] = dataSources;
        }

        var newEntry = new JsonObject
        {
            ["Name"] = collectionName,
            ["Schema"] = schema,
            ["IsSampleData"] = false,
            ["IsWritable"] = true,
            ["Type"] = "StaticDataSourceInfo",
            ["OriginalSchema"] = schema,
            ["Data"] = sampleArray.ToJsonString(),
            ["OriginalName"] = collectionName,
            ["OrderedColumnNames"] = new JsonArray(columns.Select(c => JsonValue.Create(c.Name)).ToArray()),
        };

        var replaced = false;
        for (var i = 0; i < dataSources.Count; i++)
        {
            if (dataSources[i] is not JsonObject ds)
            {
                continue;
            }

            var name = ds["Name"]?.GetValue<string>() ?? string.Empty;
            if (!string.Equals(name, collectionName, StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            dataSources[i] = newEntry;
            replaced = true;
            break;
        }

        if (!replaced)
        {
            dataSources.Add(newEntry);
        }

        root["DataSources"] = dataSources;
        File.WriteAllText(dataSourcesPath, root.ToJsonString(JsonOptions));
    }

    public static void UpsertDataSourceFromJson(string unpackDirectory, string dataSourceJsonPath)
    {
        if (string.IsNullOrWhiteSpace(unpackDirectory) || !Directory.Exists(unpackDirectory))
        {
            throw new DirectoryNotFoundException($"Unpack directory not found: '{unpackDirectory}'.");
        }

        if (string.IsNullOrWhiteSpace(dataSourceJsonPath) || !File.Exists(dataSourceJsonPath))
        {
            throw new FileNotFoundException($"Data source JSON file was not found: '{dataSourceJsonPath}'.", dataSourceJsonPath);
        }

        JsonObject newEntry;
        try
        {
            newEntry = JsonNode.Parse(File.ReadAllText(dataSourceJsonPath)) as JsonObject
                ?? throw new InvalidDataException("Data source JSON must be a JSON object.");
        }
        catch (Exception ex) when (ex is JsonException or InvalidDataException)
        {
            throw new InvalidDataException($"Data source JSON is invalid: '{dataSourceJsonPath}'.", ex);
        }

        var name = newEntry["Name"]?.GetValue<string>() ?? string.Empty;
        if (string.IsNullOrWhiteSpace(name))
        {
            throw new InvalidDataException("Data source JSON must include a non-empty 'Name' property.");
        }

        var (_, root, dataSources) = OpenDataSourcesDocument(unpackDirectory);
        UpsertDataSourceEntry(dataSources, newEntry);
        root["DataSources"] = dataSources;
        SaveDataSourcesDocument(unpackDirectory, root);
    }

    public static bool RemoveDataSource(string unpackDirectory, string dataSourceName)
    {
        if (string.IsNullOrWhiteSpace(unpackDirectory) || !Directory.Exists(unpackDirectory))
        {
            throw new DirectoryNotFoundException($"Unpack directory not found: '{unpackDirectory}'.");
        }

        if (string.IsNullOrWhiteSpace(dataSourceName))
        {
            throw new ArgumentException("Data source name must be provided.", nameof(dataSourceName));
        }

        var (_, root, dataSources) = OpenDataSourcesDocument(unpackDirectory);
        var removed = false;
        for (var i = dataSources.Count - 1; i >= 0; i--)
        {
            if (dataSources[i] is not JsonObject ds)
            {
                continue;
            }

            var name = ds["Name"]?.GetValue<string>() ?? string.Empty;
            if (!string.Equals(name, dataSourceName, StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            CacheRemovedDataSource(unpackDirectory, ds, i);
            dataSources.RemoveAt(i);
            removed = true;
        }

        if (removed)
        {
            root["DataSources"] = dataSources;
            SaveDataSourcesDocument(unpackDirectory, root);
        }

        return removed;
    }

    public static async Task UpsertDataverseTableDataSourceFromEnvironmentAsync(
        string unpackDirectory,
        string environmentUrl,
        string tableLogicalName,
        string? dataSourceName = null,
        string? datasetName = null,
        string? apiId = null)
    {
        if (string.IsNullOrWhiteSpace(unpackDirectory) || !Directory.Exists(unpackDirectory))
        {
            throw new DirectoryNotFoundException($"Unpack directory not found: '{unpackDirectory}'.");
        }

        if (string.IsNullOrWhiteSpace(environmentUrl))
        {
            throw new ArgumentException("Environment URL must be provided.", nameof(environmentUrl));
        }

        if (string.IsNullOrWhiteSpace(tableLogicalName))
        {
            throw new ArgumentException("Dataverse table logical name must be provided.", nameof(tableLogicalName));
        }

        var normalizedEnvironmentUrl = NormalizeEnvironmentUrl(environmentUrl);
        var normalizedTable = tableLogicalName.Trim();
        var escapedTable = EscapeODataLiteral(normalizedTable);
        var normalizedDatasetName = string.IsNullOrWhiteSpace(datasetName) ? "default.cds" : datasetName;

        if (TryRestoreRemovedDataSource(unpackDirectory, dataSourceName, normalizedDatasetName, normalizedTable, out var restoredEntry, out var originalIndex))
        {
            var (_, restoredRoot, restoredDataSources) = OpenDataSourcesDocument(unpackDirectory);
            UpsertDataSourceEntry(restoredDataSources, restoredEntry!, originalIndex);
            restoredRoot["DataSources"] = restoredDataSources;
            SaveDataSourcesDocument(unpackDirectory, restoredRoot);
            return;
        }

        var token = await AcquireDataverseAccessTokenAsync(normalizedEnvironmentUrl);

        var entityMetadata = await DataverseGetJsonAsync(
            normalizedEnvironmentUrl,
            token,
            $"EntityDefinitions(LogicalName='{escapedTable}')?$select=LogicalName,LogicalCollectionName,EntitySetName,PrimaryIdAttribute,PrimaryNameAttribute,ObjectTypeCode,DisplayName,DisplayCollectionName");

        var allAttributes = await DataverseGetJsonAsync(
            normalizedEnvironmentUrl,
            token,
            $"EntityDefinitions(LogicalName='{escapedTable}')/Attributes?$select=LogicalName,DisplayName");

        var booleanAttrPayload = await DataverseGetJsonAsync(normalizedEnvironmentUrl, token,
            $"EntityDefinitions(LogicalName='{escapedTable}')/Attributes/Microsoft.Dynamics.CRM.BooleanAttributeMetadata?$select=LogicalName,SchemaName,DisplayName&$expand=OptionSet");
        var picklistAttrPayload = await DataverseGetJsonAsync(normalizedEnvironmentUrl, token,
            $"EntityDefinitions(LogicalName='{escapedTable}')/Attributes/Microsoft.Dynamics.CRM.PicklistAttributeMetadata?$select=LogicalName,SchemaName,DisplayName&$expand=OptionSet");
        var multiPicklistAttrPayload = await DataverseGetJsonAsync(normalizedEnvironmentUrl, token,
            $"EntityDefinitions(LogicalName='{escapedTable}')/Attributes/Microsoft.Dynamics.CRM.MultiSelectPicklistAttributeMetadata?$select=LogicalName,SchemaName,DisplayName&$expand=OptionSet");
        var stateAttrPayload = await DataverseGetJsonAsync(normalizedEnvironmentUrl, token,
            $"EntityDefinitions(LogicalName='{escapedTable}')/Attributes/Microsoft.Dynamics.CRM.StateAttributeMetadata?$select=LogicalName,SchemaName,DisplayName&$expand=OptionSet");
        var statusAttrPayload = await DataverseGetJsonAsync(normalizedEnvironmentUrl, token,
            $"EntityDefinitions(LogicalName='{escapedTable}')/Attributes/Microsoft.Dynamics.CRM.StatusAttributeMetadata?$select=LogicalName,SchemaName,DisplayName&$expand=OptionSet");
        var entityNameAttrPayload = await DataverseGetJsonAsync(normalizedEnvironmentUrl, token,
            $"EntityDefinitions(LogicalName='{escapedTable}')/Attributes/Microsoft.Dynamics.CRM.EntityNameAttributeMetadata?$select=MetadataId,LogicalName,SchemaName,DisplayName&$expand=OptionSet");

        var optionAttributePayloads = new List<JsonObject>
        {
            booleanAttrPayload,
            picklistAttrPayload,
            multiPicklistAttrPayload,
            stateAttrPayload,
            statusAttrPayload,
        };

        var viewsPayload = await DataverseGetJsonAsync(
            normalizedEnvironmentUrl,
            token,
            $"savedqueries?$select=savedqueryid,name,returnedtypecode&$filter=returnedtypecode eq '{escapedTable}'");

        var defaultPublicViewPayload = await DataverseGetJsonAsync(
            normalizedEnvironmentUrl,
            token,
            $"savedqueries?$select=layoutxml&$filter=returnedtypecode eq '{escapedTable}' and isdefault eq true&$top=1");

        var formsPayload = await DataverseGetJsonAsync(
            normalizedEnvironmentUrl,
            token,
            $"systemforms?$select=formid,name,objecttypecode,type&$filter=objecttypecode eq '{escapedTable}'");

        var logicalName = entityMetadata["LogicalName"]?.GetValue<string>() ?? normalizedTable;
        var entitySetName = entityMetadata["EntitySetName"]?.GetValue<string>() ?? (logicalName + "s");
        var logicalCollectionName = entityMetadata["LogicalCollectionName"]?.GetValue<string>() ?? entitySetName;
        var displayCollectionName = GetLocalizedLabel(entityMetadata["DisplayCollectionName"], logicalCollectionName);

        var normalizedApiId = string.IsNullOrWhiteSpace(apiId)
            ? "/providers/microsoft.powerapps/apis/shared_commondataserviceforapps"
            : apiId;

        var preferredDataSourceName = string.IsNullOrWhiteSpace(dataSourceName) ? displayCollectionName : dataSourceName;

        var displayNameMap = BuildAttributeDisplayNameMap(allAttributes);
        var optionSetEntries = BuildOptionSetEntries(
            optionAttributePayloads,
            normalizedDatasetName,
            displayCollectionName,
            logicalName);

        var viewInfoEntry = BuildViewInfoEntry(
            viewsPayload,
            normalizedDatasetName,
            logicalName,
            displayCollectionName);

        var tableDefinitionObj = new JsonObject
        {
            ["TableName"] = logicalName,
            ["EntityMetadata"] = entityMetadata.ToJsonString(),
            ["PicklistOptionSetAttribute"] = picklistAttrPayload.ToJsonString(),
            ["MultiSelectPicklistOptionSetAttribute"] = multiPicklistAttrPayload.ToJsonString(),
            ["StateOptionSetAttribute"] = stateAttrPayload.ToJsonString(),
            ["StatusOptionSetAttribute"] = statusAttrPayload.ToJsonString(),
            ["BooleanOptionSetAttribute"] = booleanAttrPayload.ToJsonString(),
            ["EntityNameOptionSetAttribute"] = entityNameAttrPayload.ToJsonString(),
            ["Views"] = viewsPayload.ToJsonString(),
            ["DefaultPublicView"] = defaultPublicViewPayload.ToJsonString(),
            ["IconUrl"] = string.Empty,
            ["Forms"] = formsPayload.ToJsonString(),
        };

        var nativeEntry = new JsonObject
        {
            ["Name"] = preferredDataSourceName,
            ["IsSampleData"] = false,
            ["IsWritable"] = true,
            ["Type"] = "NativeCDSDataSourceInfo",
            ["DatasetName"] = normalizedDatasetName,
            ["EntitySetName"] = entitySetName,
            ["LogicalName"] = logicalName,
            ["PreferredName"] = displayCollectionName,
            ["IsHidden"] = false,
            ["WadlMetadata"] = new JsonObject { ["WadlXml"] = string.Empty },
            ["ApiId"] = normalizedApiId,
            ["CdsActionInfo"] = new JsonObject(),
            ["CdsFCBContext"] = JsonValue.Create("{\"FileType\":true,\"ImageExternalStorage\":true}"),
            ["TableDefinition"] = JsonValue.Create(tableDefinitionObj.ToJsonString()),
            ["NativeCDSDataSourceInfoNameMapping"] = displayNameMap,
        };

        var (_, root, dataSources) = OpenDataSourcesDocument(unpackDirectory);
        UpsertDataSourceEntry(dataSources, nativeEntry);
        foreach (var optionSetEntry in optionSetEntries)
        {
            UpsertDataSourceEntry(dataSources, optionSetEntry);
        }

        if (viewInfoEntry is not null)
        {
            UpsertDataSourceEntry(dataSources, viewInfoEntry);
        }

        root["DataSources"] = dataSources;
        SaveDataSourcesDocument(unpackDirectory, root);

        UpsertQualifiedFormsValues(unpackDirectory, normalizedDatasetName, logicalName, displayCollectionName, formsPayload);
    }

    private static async Task<string> AcquireDataverseAccessTokenAsync(string environmentUrl)
    {
        var uri = new Uri(environmentUrl);
        var scope = $"{uri.Scheme}://{uri.Host}/.default";
        var credential = new DeviceCodeCredential(new DeviceCodeCredentialOptions
        {
            TenantId = "organizations",
            ClientId = "04b07795-8ddb-461a-bbee-02f9e1bf7b46",
            DeviceCodeCallback = (code, _) =>
            {
                Console.WriteLine(code.Message);
                return Task.CompletedTask;
            },
        });

        var token = await credential.GetTokenAsync(new TokenRequestContext([scope]));
        return token.Token;
    }

    private static async Task<JsonObject> DataverseGetJsonAsync(string environmentUrl, string accessToken, string relativePath)
    {
        var baseUrl = environmentUrl.TrimEnd('/');
        var url = relativePath.StartsWith("http://", StringComparison.OrdinalIgnoreCase)
                  || relativePath.StartsWith("https://", StringComparison.OrdinalIgnoreCase)
            ? relativePath
            : $"{baseUrl}/api/data/v9.2/{relativePath}";

        using var req = new HttpRequestMessage(HttpMethod.Get, url);
        req.Headers.Authorization = new AuthenticationHeaderValue("Bearer", accessToken);
        req.Headers.Accept.Clear();
        req.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
        req.Headers.Add("OData-MaxVersion", "4.0");
        req.Headers.Add("OData-Version", "4.0");

        using var res = await DataverseHttpClient.SendAsync(req);
        var body = await res.Content.ReadAsStringAsync();
        if (!res.IsSuccessStatusCode)
        {
            throw new InvalidDataException($"Dataverse request failed ({(int)res.StatusCode} {res.ReasonPhrase}) for '{relativePath}'. Response: {body}");
        }

        return JsonNode.Parse(body) as JsonObject
               ?? throw new InvalidDataException($"Dataverse response was not a JSON object for '{relativePath}'.");
    }

    private static List<JsonObject> BuildOptionSetEntries(
        IEnumerable<JsonObject> optionAttributePayloads,
        string datasetName,
        string relatedEntityDisplayName,
        string relatedEntityLogicalName)
    {
        var results = new List<JsonObject>();
        foreach (var payload in optionAttributePayloads)
        {
            var values = payload["value"] as JsonArray;
            if (values is null)
            {
                continue;
            }

            foreach (var attr in values.OfType<JsonObject>())
            {
                var logicalName = attr["LogicalName"]?.GetValue<string>() ?? string.Empty;
                if (string.IsNullOrWhiteSpace(logicalName))
                {
                    continue;
                }

                var optionSet = attr["OptionSet"] as JsonObject;
                if (optionSet is null)
                {
                    continue;
                }

                var optionSetType = optionSet["OptionSetType"]?.GetValue<string>() ?? string.Empty;
                var optionSetName = optionSet["Name"]?.GetValue<string>() ?? $"{relatedEntityLogicalName}_{logicalName}";
                var displayName = GetLocalizedLabel(attr["DisplayName"], logicalName);

                var mapping = new JsonObject();
                var isBoolean = string.Equals(optionSetType, "Boolean", StringComparison.OrdinalIgnoreCase);
                if (isBoolean)
                {
                    AddBooleanOption(optionSet, "TrueOption", mapping);
                    AddBooleanOption(optionSet, "FalseOption", mapping);
                }
                else
                {
                    var options = optionSet["Options"] as JsonArray;
                    if (options is not null)
                    {
                        foreach (var option in options.OfType<JsonObject>())
                        {
                            var value = option["Value"]?.GetValue<int?>();
                            if (value is null)
                            {
                                continue;
                            }

                            var label = GetLocalizedLabel(option["Label"], value.Value.ToString(CultureInfo.InvariantCulture));
                            mapping[value.Value.ToString(CultureInfo.InvariantCulture)] = label;
                        }
                    }
                }

                if (mapping.Count == 0)
                {
                    continue;
                }

                results.Add(new JsonObject
                {
                    ["Type"] = "OptionSetInfo",
                    ["Name"] = optionSetName,
                    ["DatasetName"] = datasetName,
                    ["DisplayName"] = $"{displayName} ({relatedEntityDisplayName})",
                    ["RelatedEntityName"] = relatedEntityDisplayName,
                    ["RelatedColumnInvariantName"] = logicalName,
                    ["OptionSetInfoNameMapping"] = mapping,
                    ["OptionSetIsGlobal"] = optionSet["IsGlobal"]?.GetValue<bool?>() ?? false,
                    ["OptionSetIsBooleanValued"] = isBoolean,
                    ["OptionSetTypeKey"] = ToOptionSetTypeKey(optionSetType),
                    ["OptionSetReference"] = new JsonObject
                    {
                        ["OptionSetReferenceItem0"] = new JsonObject
                        {
                            ["OptionSetReferenceEntityName"] = relatedEntityDisplayName,
                            ["OptionSetReferenceColumnName"] = logicalName,
                        },
                    },
                });
            }
        }

        return results;
    }

    private static void AddBooleanOption(JsonObject optionSet, string optionPropertyName, JsonObject output)
    {
        var option = optionSet[optionPropertyName] as JsonObject;
        if (option is null)
        {
            return;
        }

        var value = option["Value"]?.GetValue<int?>();
        if (value is null)
        {
            return;
        }

        var label = GetLocalizedLabel(option["Label"], value.Value.ToString(CultureInfo.InvariantCulture));
        output[value.Value.ToString(CultureInfo.InvariantCulture)] = label;
    }

    private static JsonObject? BuildViewInfoEntry(JsonObject viewsPayload, string datasetName, string logicalName, string displayCollectionName)
    {
        var values = viewsPayload["value"] as JsonArray;
        if (values is null || values.Count == 0)
        {
            return null;
        }

        var map = new JsonObject();
        foreach (var view in values.OfType<JsonObject>())
        {
            var id = view["savedqueryid"]?.GetValue<string>() ?? string.Empty;
            var name = view["name"]?.GetValue<string>() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(id) || string.IsNullOrWhiteSpace(name))
            {
                continue;
            }

            map[id] = name;
        }

        if (map.Count == 0)
        {
            return null;
        }

        return new JsonObject
        {
            ["Type"] = "ViewInfo",
            ["Name"] = $"{datasetName}_{logicalName}_views",
            ["DisplayName"] = $"{displayCollectionName} (Views)",
            ["RelatedEntityName"] = displayCollectionName,
            ["ViewInfoNameMapping"] = map,
        };
    }

    private static JsonObject BuildAttributeDisplayNameMap(JsonObject allAttributesPayload)
    {
        var map = new JsonObject();
        var values = allAttributesPayload["value"] as JsonArray;
        if (values is null)
        {
            return map;
        }

        foreach (var attr in values.OfType<JsonObject>())
        {
            var logical = attr["LogicalName"]?.GetValue<string>() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(logical))
            {
                continue;
            }

            var display = GetLocalizedLabel(attr["DisplayName"], logical);
            map[logical] = display;
        }

        return map;
    }

    private static void UpsertQualifiedFormsValues(
        string unpackDirectory,
        string datasetName,
        string logicalName,
        string displayCollectionName,
        JsonObject formsPayload)
    {
        var forms = formsPayload["value"] as JsonArray;
        if (forms is null || forms.Count == 0)
        {
            return;
        }

        var values = new JsonObject();
        foreach (var form in forms.OfType<JsonObject>())
        {
            var formName = form["name"]?.GetValue<string>() ?? string.Empty;
            var formId = form["formid"]?.GetValue<string>() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(formName) || string.IsNullOrWhiteSpace(formId))
            {
                continue;
            }

            values[formName] = formId;
        }

        if (values.Count == 0)
        {
            return;
        }

        var path = Path.Combine(unpackDirectory, "References", "QualifiedValues.json");
        Directory.CreateDirectory(Path.GetDirectoryName(path)!);

        JsonObject root;
        JsonArray arr;
        if (File.Exists(path)
            && JsonNode.Parse(File.ReadAllText(path)) is JsonObject existingRoot
            && existingRoot["QualifiedValues"] is JsonArray existingArray)
        {
            root = existingRoot;
            arr = existingArray;
        }
        else
        {
            root = new JsonObject();
            arr = new JsonArray();
            root["QualifiedValues"] = arr;
        }

        var ns = $"{displayCollectionName} (Forms)";
        var kind = $"{datasetName}_{logicalName}_forms";
        var newEntry = new JsonObject
        {
            ["Namespace"] = ns,
            ["Kind"] = kind,
            ["Values"] = values,
        };

        var replaced = false;
        for (var i = 0; i < arr.Count; i++)
        {
            if (arr[i] is not JsonObject existing)
            {
                continue;
            }

            var existingNs = existing["Namespace"]?.GetValue<string>() ?? string.Empty;
            var existingKind = existing["Kind"]?.GetValue<string>() ?? string.Empty;
            if (!string.Equals(existingNs, ns, StringComparison.OrdinalIgnoreCase)
                || !string.Equals(existingKind, kind, StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            arr[i] = newEntry;
            replaced = true;
            break;
        }

        if (!replaced)
        {
            arr.Add(newEntry);
        }

        root["QualifiedValues"] = arr;
        File.WriteAllText(path, root.ToJsonString(JsonOptions));
    }

    private static string NormalizeEnvironmentUrl(string environmentUrl)
    {
        var uri = new Uri(environmentUrl, UriKind.Absolute);
        return $"{uri.Scheme}://{uri.Host}";
    }

    private static string EscapeODataLiteral(string value)
    {
        return value.Replace("'", "''", StringComparison.Ordinal);
    }

    private static string ToOptionSetTypeKey(string optionSetType)
    {
        if (string.Equals(optionSetType, "Boolean", StringComparison.OrdinalIgnoreCase))
        {
            return "BooleanType";
        }

        if (string.Equals(optionSetType, "State", StringComparison.OrdinalIgnoreCase))
        {
            return "StateType";
        }

        if (string.Equals(optionSetType, "Status", StringComparison.OrdinalIgnoreCase))
        {
            return "StatusType";
        }

        if (string.Equals(optionSetType, "MultiSelectPicklist", StringComparison.OrdinalIgnoreCase))
        {
            return "MultiSelectPicklistType";
        }

        return "PicklistType";
    }

    private static string GetLocalizedLabel(JsonNode? labelNode, string fallback)
    {
        if (labelNode is JsonObject labelObject)
        {
            var userLabel = labelObject["UserLocalizedLabel"] as JsonObject;
            var userText = userLabel?["Label"]?.GetValue<string>();
            if (!string.IsNullOrWhiteSpace(userText))
            {
                return userText;
            }

            var localized = labelObject["LocalizedLabels"] as JsonArray;
            var firstText = localized?
                .OfType<JsonObject>()
                .Select(o => o["Label"]?.GetValue<string>() ?? string.Empty)
                .FirstOrDefault(s => !string.IsNullOrWhiteSpace(s));
            if (!string.IsNullOrWhiteSpace(firstText))
            {
                return firstText;
            }
        }

        return fallback;
    }

    public static void UnpackToDirectory(string msappPath, string outputDirectory)
    {
        if (Directory.Exists(outputDirectory))
        {
            Directory.Delete(outputDirectory, true);
        }

        Directory.CreateDirectory(outputDirectory);
        ZipFile.ExtractToDirectory(msappPath, outputDirectory, overwriteFiles: true);
    }

    public static void InitEmptyAppDirectory(string outputDirectory, string screenName = "Screen1")
    {
        if (string.IsNullOrWhiteSpace(outputDirectory))
        {
            throw new ArgumentException("Output directory must be provided.", nameof(outputDirectory));
        }

        if (string.IsNullOrWhiteSpace(screenName))
        {
            throw new ArgumentException("Screen name must be provided.", nameof(screenName));
        }

        var normalizedScreenName = screenName.Trim();
        if (!IdentifierRegex.IsMatch(normalizedScreenName))
        {
            throw new InvalidDataException($"Invalid screen name '{normalizedScreenName}'. Use a valid Power Fx identifier.");
        }

        if (Directory.Exists(outputDirectory))
        {
            var hasExistingContent = Directory.EnumerateFileSystemEntries(outputDirectory).Any();
            if (hasExistingContent)
            {
                throw new InvalidOperationException($"Output directory '{outputDirectory}' already exists and is not empty.");
            }
        }

        Directory.CreateDirectory(outputDirectory);

        var serializer = new SerializerBuilder().Build();
        var entries = new Dictionary<string, byte[]>(StringComparer.OrdinalIgnoreCase);

        var appTop = CreateDefaultApp(normalizedScreenName);
        var screenTop = CreateDefaultScreen(normalizedScreenName);
        screenTop["ControlUniqueId"] = "4";
        screenTop["Rules"] = new JsonArray
        {
            new JsonObject
            {
                ["Property"] = "LoadingSpinnerColor",
                ["Category"] = "Design",
                ["InvariantScript"] = "RGBA(56, 96, 178, 1)",
                ["RuleProviderType"] = "Unknown",
            },
        };
        screenTop["ControlPropertyState"] = new JsonArray("LoadingSpinnerColor");

        entries["Controls/1.json"] = Encoding.UTF8.GetBytes(WrapTopParent(appTop).ToJsonString(JsonOptions));
        entries["Controls/4.json"] = Encoding.UTF8.GetBytes(WrapTopParent(screenTop).ToJsonString(JsonOptions));

        var appYamlPayload = new Dictionary<string, object?>
        {
            ["App"] = new Dictionary<string, object?>
            {
                ["Properties"] = new Dictionary<string, object?>
                {
                    ["StartScreen"] = "=" + normalizedScreenName,
                    ["Theme"] = "=PowerAppsTheme",
                },
            },
        };

        var screenYamlPayload = new Dictionary<string, object?>
        {
            ["Screens"] = new Dictionary<string, object?>
            {
                [normalizedScreenName] = new Dictionary<string, object?>
                {
                    ["Children"] = new List<object?>(),
                },
            },
        };

        var editorStatePayload = new Dictionary<string, object?>
        {
            ["EditorState"] = new Dictionary<string, object?>
            {
                ["ScreensOrder"] = new List<string> { normalizedScreenName },
                ["ComponentDefinitionsOrder"] = new List<string>(),
            },
        };

        static string WithYamlHeader(string body)
            => string.Join(Environment.NewLine, HeaderLines) + Environment.NewLine + body;

        entries["Src/App.pa.yaml"] = Encoding.UTF8.GetBytes(WithYamlHeader(serializer.Serialize(appYamlPayload)));
        entries[$"Src/{normalizedScreenName}.pa.yaml"] = Encoding.UTF8.GetBytes(WithYamlHeader(serializer.Serialize(screenYamlPayload)));
        entries["Src/_EditorState.pa.yaml"] = Encoding.UTF8.GetBytes(WithYamlHeader(serializer.Serialize(editorStatePayload)));

        entries["References/DataSources.json"] = Encoding.UTF8.GetBytes("{\n  \"DataSources\": []\n}");
        entries["References/QualifiedValues.json"] = Encoding.UTF8.GetBytes("{\n  \"QualifiedValues\": []\n}");
        entries["References/Templates.json"] = Encoding.UTF8.GetBytes("{\n  \"UsedTemplates\": []\n}");
        entries["References/Themes.json"] = Encoding.UTF8.GetBytes("{\n  \"CurrentTheme\": \"v9WebLightTheme\"\n}");
        entries["References/ModernThemes.json"] = Encoding.UTF8.GetBytes("{\n  \"$schema\": \"\"\n}");
        entries["References/Resources.json"] = Encoding.UTF8.GetBytes("{\n  \"Resources\": []\n}");

        entries["Properties.json"] = Encoding.UTF8.GetBytes("{\n  \"Name\": \"App\",\n  \"ControlCount\": {\n    \"screen\": 1\n  }\n}");
        entries["Header.json"] = Encoding.UTF8.GetBytes("{}\n");

        WriteEntriesToDirectory(entries, outputDirectory);
    }

    public static void PackFromDirectory(string unpackDirectory, string outputMsappPath, bool ignoreMissingDataSources = false)
    {
        var entries = ReadEntries(unpackDirectory);
        var deserializer = new DeserializerBuilder().IgnoreUnmatchedProperties().Build();
        var serializer = new SerializerBuilder().Build();
        var templateResolver = BuildTemplateResolver(entries, unpackDirectory);
        var metadataResolver = BuildControlMetadataResolver(entries);
        var propertyResolver = BuildTemplatePropertyResolver(entries);
        var keywordResolver = BuildTemplateKeywordResolver(entries);
        var appFlags = ReadAppPreviewFlagsMap(entries);
        var flagRequirementsMap = BuildTemplateFlagRequirementsMap();

        var existingControlFiles = ParseTopParentFiles(entries, "Controls/");
        var existingComponentFiles = ParseTopParentFiles(entries, "Components/");

        var existingScreenByName = existingControlFiles.Values
            .Select(v => v["TopParent"] as JsonObject)
            .Where(v => v is not null)
            .Cast<JsonObject>()
            .Where(v => string.Equals(v["Template"]?["Name"]?.GetValue<string>(), "screen", StringComparison.OrdinalIgnoreCase))
            .ToDictionary(v => v["Name"]?.GetValue<string>() ?? string.Empty, v => v, StringComparer.OrdinalIgnoreCase);

        var existingComponentByName = existingComponentFiles.Values
            .Select(v => v["TopParent"] as JsonObject)
            .Where(v => v is not null)
            .Cast<JsonObject>()
            .ToDictionary(v => v["Name"]?.GetValue<string>() ?? string.Empty, v => v, StringComparer.OrdinalIgnoreCase);

        var allExistingNodes = new Dictionary<string, JsonObject>(StringComparer.OrdinalIgnoreCase);
        foreach (var top in existingControlFiles.Values.Select(v => v["TopParent"] as JsonObject).Where(v => v is not null).Cast<JsonObject>())
        {
            IndexByName(top, allExistingNodes);
        }

        foreach (var top in existingComponentFiles.Values.Select(v => v["TopParent"] as JsonObject).Where(v => v is not null).Cast<JsonObject>())
        {
            IndexByName(top, allExistingNodes);
        }

        var componentMetadataByName = ReadComponentMetadata(entries);

        var appTop = existingControlFiles.Values
            .Select(v => v["TopParent"] as JsonObject)
            .FirstOrDefault(v => string.Equals(v?["Name"]?.GetValue<string>(), "App", StringComparison.OrdinalIgnoreCase));

        if (appTop is null)
        {
            throw new InvalidDataException("Could not find App top parent in Controls/*.json.");
        }

        var appControlFileName = existingControlFiles.FirstOrDefault(kv => string.Equals(kv.Value["TopParent"]?["Name"]?.GetValue<string>(), "App", StringComparison.OrdinalIgnoreCase)).Key;
        if (string.IsNullOrWhiteSpace(appControlFileName))
        {
            appControlFileName = "Controls/1.json";
        }

        if (entries.TryGetValue("Src/App.pa.yaml", out var appYamlBytes))
        {
            var appYaml = Encoding.UTF8.GetString(appYamlBytes);
            if (TryParseYamlMap(deserializer, appYaml, out var appRoot)
                && TryGetMap(appRoot, "App", out var appMap)
                && TryGetMap(appMap, "Properties", out var appProps))
            {
                UpsertProperties(appTop, appProps);
            }
        }

        var screenPayloads = new Dictionary<string, Dictionary<object, object?>>(StringComparer.OrdinalIgnoreCase);
        var componentPayloads = new Dictionary<string, Dictionary<object, object?>>(StringComparer.OrdinalIgnoreCase);
        var screenOrderFromFiles = new List<string>();
        var componentOrderFromFiles = new List<string>();

        foreach (var (path, bytes) in entries.Where(e => e.Key.StartsWith("Src/", StringComparison.OrdinalIgnoreCase) && e.Key.EndsWith(".pa.yaml", StringComparison.OrdinalIgnoreCase)).OrderBy(e => e.Key, StringComparer.OrdinalIgnoreCase))
        {
            var fileName = Path.GetFileName(path);
            if (string.Equals(fileName, "App.pa.yaml", StringComparison.OrdinalIgnoreCase)
                || string.Equals(fileName, "_EditorState.pa.yaml", StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            var yaml = Encoding.UTF8.GetString(bytes);
            if (!TryParseYamlMap(deserializer, yaml, out var root))
            {
                continue;
            }

            if (path.StartsWith("Src/Components/", StringComparison.OrdinalIgnoreCase))
            {
                if (TryGetMap(root, "ComponentDefinitions", out var defs))
                {
                    foreach (var kv in defs)
                    {
                        var n = kv.Key?.ToString() ?? string.Empty;
                        if (string.IsNullOrWhiteSpace(n) || kv.Value is not Dictionary<object, object?> payload)
                        {
                            continue;
                        }

                        componentPayloads[n] = payload;
                        if (!componentOrderFromFiles.Contains(n, StringComparer.OrdinalIgnoreCase))
                        {
                            componentOrderFromFiles.Add(n);
                        }
                    }
                }

                continue;
            }

            if (TryGetMap(root, "Screens", out var screens))
            {
                foreach (var kv in screens)
                {
                    var n = kv.Key?.ToString() ?? string.Empty;
                    if (string.IsNullOrWhiteSpace(n) || kv.Value is not Dictionary<object, object?> payload)
                    {
                        continue;
                    }

                    screenPayloads[n] = payload;
                    if (!screenOrderFromFiles.Contains(n, StringComparer.OrdinalIgnoreCase))
                    {
                        screenOrderFromFiles.Add(n);
                    }
                }
            }
        }

        var idAllocator = new ControlIdAllocator(existingControlFiles.Values
            .Concat(existingComponentFiles.Values)
            .Select(v => v["TopParent"] as JsonObject)
            .Where(v => v is not null)
            .Cast<JsonObject>()
            .SelectMany(t => Flatten(t))
            .Select(n => n["ControlUniqueId"]?.GetValue<string>() ?? string.Empty));

        var topControlFiles = new Dictionary<string, JsonObject>(StringComparer.OrdinalIgnoreCase)
        {
            [appControlFileName] = WrapTopParent(appTop),
        };

        var screenIndex = 0;
        foreach (var screenName in screenPayloads.Keys.OrderBy(n => n, StringComparer.OrdinalIgnoreCase))
        {
            var payload = screenPayloads[screenName];
            var existing = existingScreenByName.TryGetValue(screenName, out var e) ? e : null;
            var root = existing is null ? CreateDefaultScreen(screenName) : (JsonObject)existing.DeepClone();

            root["Name"] = screenName;
            root["Parent"] = string.Empty;
            root["Template"] ??= new JsonObject();
            (root["Template"] as JsonObject)!["Name"] = "screen";
            (root["Template"] as JsonObject)!["Id"] ??= "http://microsoft.com/appmagic/screen";
            (root["Template"] as JsonObject)!["Version"] ??= "1.0";
            root["Index"] = screenIndex;
            root["PublishOrderIndex"] = 0;
            root["ControlUniqueId"] = idAllocator.GetOrCreate(screenName, existing);

            ApplyFromYaml(root, payload, screenName, allExistingNodes, idAllocator, templateResolver, metadataResolver, propertyResolver, keywordResolver, appFlags, flagRequirementsMap);

            var fileName = existingControlFiles.FirstOrDefault(kv => string.Equals(kv.Value["TopParent"]?["Name"]?.GetValue<string>(), screenName, StringComparison.OrdinalIgnoreCase)).Key;
            if (string.IsNullOrWhiteSpace(fileName))
            {
                fileName = $"Controls/{root["ControlUniqueId"]?.GetValue<string>()}.json";
            }

            topControlFiles[fileName] = WrapTopParent(root);
            screenIndex++;
        }

        var topComponentFiles = new Dictionary<string, JsonObject>(StringComparer.OrdinalIgnoreCase);
        foreach (var componentName in componentPayloads.Keys.OrderBy(n => n, StringComparer.OrdinalIgnoreCase))
        {
            var payload = componentPayloads[componentName];
            var existing = existingComponentByName.TryGetValue(componentName, out var e) ? e : null;
            var root = existing is null ? CreateDefaultComponent(componentName) : (JsonObject)existing.DeepClone();

            root["Name"] = componentName;
            root["Parent"] = string.Empty;
            root["Template"] ??= new JsonObject();
            var template = (JsonObject)root["Template"]!;
            template["Id"] = "http://microsoft.com/appmagic/Component";
            template["Version"] ??= "1.0";
            template["IsComponentDefinition"] = true;
            template["Name"] = ResolveComponentTemplateName(componentName, template, componentMetadataByName);

            root["ControlUniqueId"] = idAllocator.GetOrCreate(componentName, existing);

            ApplyFromYaml(root, payload, componentName, allExistingNodes, idAllocator, templateResolver, metadataResolver, propertyResolver, keywordResolver, appFlags, flagRequirementsMap);

            var fileName = existingComponentFiles.FirstOrDefault(kv => string.Equals(kv.Value["TopParent"]?["Name"]?.GetValue<string>(), componentName, StringComparison.OrdinalIgnoreCase)).Key;
            if (string.IsNullOrWhiteSpace(fileName))
            {
                fileName = $"Components/{root["ControlUniqueId"]?.GetValue<string>()}.json";
            }

            topComponentFiles[fileName] = WrapTopParent(root);
        }

        UpdateUsedTemplates(entries, topControlFiles, topComponentFiles);
        var galleryTemplateDescriptor = BuildGalleryTemplateDescriptor(entries);
        ApplyLegacyControlParityTransforms(topControlFiles, topComponentFiles, galleryTemplateDescriptor);
        metadataResolver.NormalizeReservedEnumTokensInTopFiles(topControlFiles);
        metadataResolver.NormalizeReservedEnumTokensInTopFiles(topComponentFiles);

        ReplaceEntries(entries, "Controls/", topControlFiles);
        ReplaceEntries(entries, "Components/", topComponentFiles);

        UpdateComponentMetadata(entries, componentPayloads, topComponentFiles);
        UpdatePropertiesControlCount(entries, topControlFiles, topComponentFiles);
        var discoveredScreens = topControlFiles.Values
            .Select(v => v["TopParent"] as JsonObject)
            .Where(v => v is not null)
            .Cast<JsonObject>()
            .Where(v => string.Equals(v["Template"]?["Name"]?.GetValue<string>(), "screen", StringComparison.OrdinalIgnoreCase))
            .Select(v => v["Name"]?.GetValue<string>() ?? string.Empty)
            .Where(n => !string.IsNullOrWhiteSpace(n))
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .ToList();

        var discoveredComponents = topComponentFiles.Values
            .Select(v => v["TopParent"] as JsonObject)
            .Where(v => v is not null)
            .Cast<JsonObject>()
            .Select(v => v["Name"]?.GetValue<string>() ?? string.Empty)
            .Where(n => !string.IsNullOrWhiteSpace(n))
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .ToList();

        UpdateEditorState(entries, serializer, deserializer, screenOrderFromFiles, componentOrderFromFiles, discoveredScreens, discoveredComponents);
        NormalizeHostControlMetadata(entries);
        NormalizeAppInfoRuleProviders(entries);
        NormalizeThemeMetadata(entries);
        NormalizeModernThemeMetadata(entries);
        NormalizePropertiesMetadata(entries);
        NormalizeHeaderMetadata(entries);
        EnsurePublishInfoResource(entries);
        NormalizeDataSourceMetadata(entries);
        RemoveStaticCollectionDataSources(entries, topControlFiles, topComponentFiles);
        if (!ignoreMissingDataSources)
            ValidateDataSourcesContainCollections(entries, topControlFiles, topComponentFiles);

        WriteMsApp(entries, outputMsappPath);
    }

    private static void NormalizeThemeMetadata(Dictionary<string, byte[]> entries)
    {
        JsonObject root;
        if (entries.TryGetValue("References/Themes.json", out var bytes)
            && JsonNode.Parse(bytes) is JsonObject parsed)
        {
            root = parsed;
        }
        else
        {
            root = new JsonObject();
        }

        if ((root["CustomThemes"] as JsonArray)?.Count is null or 0)
        {
            var embeddedThemes = TryReadEmbeddedReferenceJson("References/Themes.json");
            if (embeddedThemes?["CustomThemes"] is JsonArray embeddedCustomThemes && embeddedCustomThemes.Count > 0)
            {
                root["CustomThemes"] = embeddedCustomThemes.DeepClone();
            }
        }

        // Studio-authored modern apps default to this pointer.
        root["CurrentTheme"] = "v9WebLightTheme";
        entries["References/Themes.json"] = Encoding.UTF8.GetBytes(root.ToJsonString(JsonOptions));
    }

    private static void NormalizeModernThemeMetadata(Dictionary<string, byte[]> entries)
    {
        JsonObject root;
        if (entries.TryGetValue("References/ModernThemes.json", out var bytes)
            && JsonNode.Parse(bytes) is JsonObject parsed)
        {
            root = parsed;
        }
        else
        {
            root = new JsonObject();
        }

        if (root["Themes"] is not JsonArray themes || themes.Count == 0)
        {
            var embedded = TryReadEmbeddedReferenceJson("References/ModernThemes.json");
            if (embedded?["Themes"] is JsonArray embeddedThemes && embeddedThemes.Count > 0)
            {
                root["Themes"] = embeddedThemes.DeepClone();
            }
            else
            {
                root["Themes"] = new JsonArray
                {
                    new JsonObject
                    {
                        ["EntityName"] = "PowerAppsTheme",
                        ["ThemeName"] = "PowerAppsTheme",
                    },
                };
            }
        }

        if (root["$schema"] is not null)
        {
            root.Remove("$schema");
        }

        entries["References/ModernThemes.json"] = Encoding.UTF8.GetBytes(root.ToJsonString(JsonOptions));
    }

    private static JsonObject? TryReadEmbeddedReferenceJson(string entryPath)
    {
        if (!ReadEmbeddedAllControlsEntries(out var embedded)
            || !embedded.TryGetValue(entryPath, out var bytes)
            || JsonNode.Parse(bytes) is not JsonObject parsed)
        {
            return null;
        }

        return parsed;
    }

    private static void NormalizeHostControlMetadata(Dictionary<string, byte[]> entries)
    {
        foreach (var path in entries.Keys
                     .Where(k => (k.StartsWith("Controls/", StringComparison.OrdinalIgnoreCase)
                                  || k.StartsWith("Components/", StringComparison.OrdinalIgnoreCase))
                                 && k.EndsWith(".json", StringComparison.OrdinalIgnoreCase))
                     .ToList())
        {
            if (JsonNode.Parse(entries[path]) is not JsonObject doc
                || doc["TopParent"] is not JsonObject topParent)
            {
                continue;
            }

            var changed = false;
            foreach (var node in Flatten(topParent))
            {
                var template = node["Template"] as JsonObject;
                if (template is null)
                {
                    continue;
                }

                var templateName = template["Name"]?.GetValue<string>() ?? string.Empty;
                var templateId = template["Id"]?.GetValue<string>() ?? string.Empty;
                var isHost = string.Equals(templateName, "hostControl", StringComparison.OrdinalIgnoreCase)
                             || templateId.EndsWith("/hostcontrol", StringComparison.OrdinalIgnoreCase);
                if (!isHost)
                {
                    continue;
                }

                if (template["HostType"] is null)
                {
                    template["HostType"] = "Default";
                    changed = true;
                }

                if (node["HasDynamicProperties"] is null)
                {
                    node["HasDynamicProperties"] = false;
                    changed = true;
                }
            }

            if (changed)
            {
                entries[path] = Encoding.UTF8.GetBytes(doc.ToJsonString(JsonOptions));
            }
        }
    }

    private static void NormalizeAppInfoRuleProviders(Dictionary<string, byte[]> entries)
    {
        foreach (var path in entries.Keys
                     .Where(k => (k.StartsWith("Controls/", StringComparison.OrdinalIgnoreCase)
                                  || k.StartsWith("Components/", StringComparison.OrdinalIgnoreCase))
                                 && k.EndsWith(".json", StringComparison.OrdinalIgnoreCase))
                     .ToList())
        {
            if (JsonNode.Parse(entries[path]) is not JsonObject doc
                || doc["TopParent"] is not JsonObject topParent)
            {
                continue;
            }

            var changed = false;
            foreach (var node in Flatten(topParent))
            {
                if (!IsAppInfoControl(node))
                {
                    continue;
                }

                var rules = (node["Rules"] as JsonArray) ?? new JsonArray();
                foreach (var rule in rules.OfType<JsonObject>())
                {
                    var property = rule["Property"]?.GetValue<string>() ?? string.Empty;
                    if (string.Equals(property, "OnStart", StringComparison.OrdinalIgnoreCase)
                        || string.Equals(property, "StartScreen", StringComparison.OrdinalIgnoreCase))
                    {
                        if (!string.Equals(rule["RuleProviderType"]?.GetValue<string>() ?? string.Empty, "User", StringComparison.OrdinalIgnoreCase))
                        {
                            rule["RuleProviderType"] = "User";
                            changed = true;
                        }
                    }
                }

                if (NormalizeAppInfoStateAndRuleOrder(node))
                {
                    changed = true;
                }
            }

            if (changed)
            {
                entries[path] = Encoding.UTF8.GetBytes(doc.ToJsonString(JsonOptions));
            }
        }
    }

    private static bool NormalizeAppInfoStateAndRuleOrder(JsonObject appNode)
    {
        var changed = false;

        var preferredRuleOrder = new[]
        {
            "ConfirmExit", "BackEnabled", "MinScreenHeight", "MinScreenWidth", "Theme", "OnStart", "SizeBreakpoints", "StartScreen",
        };

        var existingRules = ((appNode["Rules"] as JsonArray) ?? new JsonArray()).OfType<JsonObject>().ToList();
        var ruleByProperty = new Dictionary<string, JsonObject>(StringComparer.OrdinalIgnoreCase);
        foreach (var rule in existingRules)
        {
            var property = rule["Property"]?.GetValue<string>() ?? string.Empty;
            if (!string.IsNullOrWhiteSpace(property) && !ruleByProperty.ContainsKey(property))
            {
                ruleByProperty[property] = rule;
            }
        }

        var reorderedRules = new JsonArray();
        foreach (var property in preferredRuleOrder)
        {
            if (ruleByProperty.TryGetValue(property, out var found))
            {
                reorderedRules.Add(found.DeepClone());
            }
        }

        foreach (var rule in existingRules)
        {
            var property = rule["Property"]?.GetValue<string>() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(property)
                || preferredRuleOrder.Contains(property, StringComparer.OrdinalIgnoreCase))
            {
                continue;
            }

            reorderedRules.Add(rule.DeepClone());
        }

        var oldRules = ((appNode["Rules"] as JsonArray) ?? new JsonArray()).ToJsonString(JsonOptions);
        var newRules = reorderedRules.ToJsonString(JsonOptions);
        if (!string.Equals(oldRules, newRules, StringComparison.Ordinal))
        {
            appNode["Rules"] = reorderedRules;
            changed = true;
        }

        var preferredStateOrder = new[]
        {
            "MinScreenHeight", "MinScreenWidth", "ConfirmExit", "SizeBreakpoints", "BackEnabled", "Theme", "StartScreen", "OnStart",
        };

        var stateByProperty = new Dictionary<string, JsonNode>(StringComparer.OrdinalIgnoreCase);
        foreach (var stateEntry in ((appNode["ControlPropertyState"] as JsonArray) ?? new JsonArray()))
        {
            var property = GetStatePropertyName(stateEntry);
            if (string.IsNullOrWhiteSpace(property) || stateByProperty.ContainsKey(property))
            {
                continue;
            }

            stateByProperty[property] = stateEntry?.DeepClone() ?? JsonValue.Create(property)!;
        }

        var reorderedState = new JsonArray();
        foreach (var property in preferredStateOrder)
        {
            if (!stateByProperty.TryGetValue(property, out var stateNode))
            {
                stateNode = string.Equals(property, "StartScreen", StringComparison.OrdinalIgnoreCase)
                            || string.Equals(property, "OnStart", StringComparison.OrdinalIgnoreCase)
                    ? CreateInvariantPropertyStateEntry(property)
                    : JsonValue.Create(property)!;
            }

            reorderedState.Add(stateNode.DeepClone());
        }

        var oldState = ((appNode["ControlPropertyState"] as JsonArray) ?? new JsonArray()).ToJsonString(JsonOptions);
        var newState = reorderedState.ToJsonString(JsonOptions);
        if (!string.Equals(oldState, newState, StringComparison.Ordinal))
        {
            appNode["ControlPropertyState"] = reorderedState;
            changed = true;
        }

        return changed;
    }

    private static void NormalizePropertiesMetadata(Dictionary<string, byte[]> entries)
    {
        JsonObject root;
        if (entries.TryGetValue("Properties.json", out var bytes)
            && JsonNode.Parse(bytes) is JsonObject parsed)
        {
            root = parsed;
        }
        else
        {
            root = new JsonObject();
        }

        var appName = TryReadPublishInfoAppName(entries);
        if (string.IsNullOrWhiteSpace(appName))
        {
            appName = "App";
        }

        EnsureString(root, "Author", "");
        EnsureName(root, appName);
        EnsureGuidString(root, "Id");
        EnsureGuidString(root, "FileID");
        EnsureString(root, "LocalConnectionReferences", "{}");
        EnsureString(root, "LocalDatabaseReferences", "");
        EnsureString(root, "LibraryDependencies", "[]");
        MergeIntoObject(root, "AppPreviewFlagsMap", BuildDefaultAppPreviewFlagsMap());
        EnsureNumber(root, "DocumentLayoutWidth", 1366);
        EnsureNumber(root, "DocumentLayoutHeight", 768);
        EnsureString(root, "DocumentLayoutOrientation", "landscape");
        EnsureBool(root, "DocumentLayoutMaintainAspectRatio", false);
        EnsureBool(root, "DocumentLayoutScaleToFit", false);
        EnsureString(root, "AppCreationSource", "AppFromScreenTemplate");
        EnsureBool(root, "DocumentLayoutLockOrientation", false);
        EnsureBool(root, "ShowStatusBar", false);
        EnsureString(root, "AppCopilotSchemaName", "");
        EnsureString(root, "DocumentAppType", "DesktopOrTablet");
        EnsureString(root, "DocumentType", "App");
        EnsureString(root, "AppDescription", "");
        EnsureString(root, "ManualOfflineProfileId", "");
        EnsureNumber(root, "DefaultConnectedDataSourceMaxGetRowsCount", 500);
        EnsureBool(root, "ContainsThirdPartyPcfControls", false);
        EnsureNumber(root, "ParserErrorCount", 0);
        EnsureNumber(root, "BindingErrorCount", 0);
        EnsureString(root, "ConnectionString", "");
        EnsureBool(root, "EnableInstrumentation", false);

        if ((root["OriginatingVersion"]?.GetValue<string>() ?? string.Empty) is var ov
            && string.IsNullOrWhiteSpace(ov))
        {
            root["OriginatingVersion"] = root["DocVersion"]?.GetValue<string>() ?? "1.348";
        }

        var hasLocalDbRefs = !string.IsNullOrWhiteSpace(root["LocalDatabaseReferences"]?.GetValue<string>() ?? string.Empty);
        if (!hasLocalDbRefs)
        {
            var localDbRefs = BuildLocalDatabaseReferences(entries);
            if (!string.IsNullOrWhiteSpace(localDbRefs))
            {
                root["LocalDatabaseReferences"] = localDbRefs;
            }
        }

        entries["Properties.json"] = Encoding.UTF8.GetBytes(root.ToJsonString(JsonOptions));
    }

    private static string TryReadPublishInfoAppName(Dictionary<string, byte[]> entries)
    {
        if (!entries.TryGetValue("Resources/PublishInfo.json", out var bytes)
            || JsonNode.Parse(bytes) is not JsonObject root)
        {
            return string.Empty;
        }

        return root["AppName"]?.GetValue<string>() ?? string.Empty;
    }

    private static void EnsureString(JsonObject root, string property, string defaultValue)
    {
        if (string.IsNullOrWhiteSpace(root[property]?.GetValue<string>() ?? string.Empty))
        {
            root[property] = defaultValue;
        }
    }

    private static void EnsureName(JsonObject root, string appName)
    {
        var current = root["Name"]?.GetValue<string>() ?? string.Empty;
        if (string.IsNullOrWhiteSpace(current))
        {
            root["Name"] = appName;
        }
    }

    private static void EnsureGuidString(JsonObject root, string property)
    {
        var value = root[property]?.GetValue<string>() ?? string.Empty;
        if (!Guid.TryParse(value, out _))
        {
            root[property] = Guid.NewGuid().ToString();
        }
    }

    private static void EnsureNumber(JsonObject root, string property, int defaultValue)
    {
        if (root[property] is not JsonValue existing
            || !(existing.TryGetValue<int>(out _) || existing.TryGetValue<long>(out _)))
        {
            root[property] = defaultValue;
        }
    }

    private static void EnsureBool(JsonObject root, string property, bool defaultValue)
    {
        if (root[property] is not JsonValue existing || !existing.TryGetValue<bool>(out _))
        {
            root[property] = defaultValue;
        }
    }

    private static void EnsureObject(JsonObject root, string property, JsonObject defaultValue)
    {
        if (root[property] is not JsonObject)
        {
            root[property] = defaultValue.DeepClone();
        }
    }

    /// <summary>
    /// Ensures <paramref name="property"/> exists as a JsonObject in <paramref name="root"/>.
    /// If the key is missing the full <paramref name="defaults"/> object is inserted.
    /// If it already exists, any keys present in <paramref name="defaults"/> but absent in
    /// the existing object are added  existing values are never overwritten.
    /// </summary>
    private static void MergeIntoObject(JsonObject root, string property, JsonObject defaults)
    {
        if (root[property] is not JsonObject existing)
        {
            root[property] = defaults.DeepClone();
            return;
        }
        foreach (var (key, value) in defaults)
        {
            if (!existing.ContainsKey(key))
            {
                existing[key] = value?.DeepClone();
            }
        }
    }

    /// <summary>
    /// Full AppPreviewFlagsMap baseline derived from a real Power Apps Studio session (v1.348).
    /// These defaults match what Studio writes when creating a new DesktopOrTablet canvas app
    /// with Dataverse connected. Individual values are never overwritten for apps that already
    /// have an AppPreviewFlagsMap  only missing keys are added.
    /// </summary>
    private static JsonObject BuildDefaultAppPreviewFlagsMap()
    {
        return new JsonObject
        {
            // --- feature flags (alphabetical) ---
            ["adaptivepaging"] = false,
            ["aibuilderserviceenrollment"] = false,
            ["allowmultiplescreensincanvaspages"] = false,
            ["appinstrumentationcorrelationtracing"] = false,
            ["appinsightserrortracing"] = false,
            ["autocreateenvironmentvariables"] = false,
            ["behaviorpropertyui"] = true,
            ["blockmovingcontrol"] = true,
            ["cdsdataformatting"] = false,
            ["classiccontrols"] = false,
            ["commentgeneratedformulasv2"] = true,
            ["consistentreturnschemafortabularfunctions"] = true,
            ["copyandmerge"] = false,
            ["dataflowanalysisenabled"] = true,
            ["datatablev2control"] = true,
            ["dataverseactionsenabled"] = true,
            ["delaycontrolrendering"] = true,
            ["delayloadscreens"] = true,
            ["disablebehaviorreturntypecheck"] = false,
            ["disableruntimepolicies"] = false,
            ["dynamicschema"] = false,
            ["enableappembeddingux"] = false,
            ["enablecanvasappruntimecopilot"] = true,
            ["enablecomponentnamemaps"] = false,
            ["enablecomponentscopeoldbehavior"] = false,
            ["enablecopilotanswercontrol"] = false,
            ["enablecopilotcontrol"] = false,
            ["enablecreateaformula"] = true,
            ["enabledataverseoffline"] = false,
            ["enableeditinmcs"] = true,
            ["enableexcelonlinebusinessv2connector"] = true,
            ["enablelegacybarcodescanner"] = false,
            ["enableonstartnavigate"] = false,
            ["enableonstart"] = true,
            ["enablepcfmoderndatasets"] = true,
            ["enablerowscopeonetonexpand"] = false,
            ["enablerpawarecomponentdependency"] = true,
            ["enablesaveloadcleardataonweb"] = true,
            ["enableupdateifdelegation"] = true,
            ["errorhandling"] = true,
            ["expandedsavedatasupport"] = true,
            ["exportimportcomponents2"] = true,
            ["externalmessage"] = false,
            ["fluentv9controls"] = false,
            ["fluentv9controlspreview"] = false,
            ["formuladataprefetch"] = true,
            ["generatedebugpublishedapp"] = false,
            ["herocontrols"] = false,
            ["improvedtabstopbehavior"] = false,
            ["isemptyrequirestableargument"] = true,
            ["keeprecentscreensloaded"] = false,
            ["loadcomponentdefinitionsondemand"] = true,
            ["longlivingcache"] = false,
            ["mobilenativerendering"] = false,
            ["nativecdsexperimental"] = true,
            ["offlineprofilegenerationemitscolumns"] = false,
            ["onegrid"] = false,
            ["optimizestartscreenpublishedappload"] = true,
            ["packagemodernruntime"] = false,
            ["pdffunction"] = false,
            ["powerfxdecimal"] = false,
            ["powerfxv1"] = false,
            ["primaryoutputpropertycoerciondeprecated"] = true,
            ["proactivecontrolrename"] = true,
            ["projectionmapping"] = true,
            ["reservedkeywords"] = false,
            ["rtlinstudiopreview"] = false,
            ["rtlsupport"] = false,
            ["sharepointselectsenabled"] = true,
            ["showclassicthemes"] = false,
            ["smartemaildatacard"] = false,
            ["supportcolumnnamesasidentifiers"] = true,
            ["tabledoesntwraprecords"] = true,
            ["useexperimentalcdsconnector"] = true,
            ["useexperimentalsqlconnector"] = true,
            ["usedisplaynamemetadata"] = true,
            ["useenforcesavedatalimits"] = true,
            ["useguiddatatypes"] = true,
            ["usenonblockingonstartrule"] = true,
            ["userdefinedtypes"] = false,
            ["webbarcodescanner"] = false,
            ["zeroalltabindexes"] = true,
        };
    }

    private static void NormalizeHeaderMetadata(Dictionary<string, byte[]> entries)
    {
        JsonObject root;
        if (entries.TryGetValue("Header.json", out var bytes)
            && JsonNode.Parse(bytes) is JsonObject parsed)
        {
            root = parsed;
        }
        else
        {
            root = new JsonObject();
        }

        // Fill in the required version fields when missing; Power Apps Studio refuses to import
        // a package with an empty or version-less Header.json.
        const string currentVersion = "1.348";
        const string structureVersion = "2.4.0";

        if (root["DocVersion"]?.GetValue<string>() is not { Length: > 0 })
            root["DocVersion"] = currentVersion;
        if (root["MinVersionToLoad"]?.GetValue<string>() is not { Length: > 0 })
            root["MinVersionToLoad"] = currentVersion;
        if (root["MSAppStructureVersion"]?.GetValue<string>() is not { Length: > 0 })
            root["MSAppStructureVersion"] = structureVersion;

        // AnalysisOptions block: ensure it exists
        if (root["AnalysisOptions"] is not JsonObject)
        {
            root["AnalysisOptions"] = new JsonObject
            {
                ["DataflowAnalysisEnabled"] = true,
                ["DataflowAnalysisFlagStateToggledByUser"] = false
            };
        }

        entries["Header.json"] = Encoding.UTF8.GetBytes(root.ToJsonString(JsonOptions));
    }

    private static void EnsurePublishInfoResource(Dictionary<string, byte[]> entries)
    {
        const string publishInfoPath = "Resources/PublishInfo.json";
        if (entries.ContainsKey(publishInfoPath))
        {
            return;
        }

        var appName = "App";
        if (entries.TryGetValue("Properties.json", out var propertiesBytes)
            && JsonNode.Parse(propertiesBytes) is JsonObject propertiesRoot)
        {
            appName = propertiesRoot["Name"]?.GetValue<string>() ?? appName;
            if (appName.EndsWith(".msapp", StringComparison.OrdinalIgnoreCase))
            {
                appName = Path.GetFileNameWithoutExtension(appName);
            }

            if (string.IsNullOrWhiteSpace(appName))
            {
                appName = "App";
            }
        }

        var publishInfo = new JsonObject
        {
            ["AppName"] = appName,
            ["BackgroundColor"] = "RGBA(0,176,240,1)",
            ["PublishTarget"] = "player",
            ["LogoFileName"] = string.Empty,
            ["IconColor"] = "RGBA(255,255,255,1)",
            ["IconName"] = "Edit",
            ["PublishResourcesLocally"] = false,
            ["PublishDataLocally"] = false,
            ["UserLocale"] = "en-US",
        };

        entries[publishInfoPath] = Encoding.UTF8.GetBytes(publishInfo.ToJsonString(JsonOptions));
    }

    private static string BuildLocalDatabaseReferences(Dictionary<string, byte[]> entries)
    {
        if (!entries.TryGetValue("References/DataSources.json", out var dsBytes))
        {
            return string.Empty;
        }

        if (JsonNode.Parse(dsBytes) is not JsonObject dsRoot || dsRoot["DataSources"] is not JsonArray dsArray)
        {
            return string.Empty;
        }

        var native = dsArray
            .OfType<JsonObject>()
            .Where(ds => string.Equals(ds["Type"]?.GetValue<string>() ?? string.Empty, "NativeCDSDataSourceInfo", StringComparison.OrdinalIgnoreCase))
            .ToList();
        if (native.Count == 0)
        {
            return string.Empty;
        }

        string instanceUrl = string.Empty;
        foreach (var ds in native)
        {
            // New format: TableDefinition is a JSON string containing Views
            var tableDefinitionStr = ds["TableDefinition"]?.GetValue<string>() ?? string.Empty;
            if (!string.IsNullOrWhiteSpace(tableDefinitionStr)
                && JsonNode.Parse(tableDefinitionStr) is JsonObject tableDefinitionObj)
            {
                var views = tableDefinitionObj["Views"]?.GetValue<string>() ?? string.Empty;
                if (!string.IsNullOrWhiteSpace(views))
                {
                    var m = Regex.Match(views, @"https://[^/]+", RegexOptions.IgnoreCase);
                    if (m.Success)
                    {
                        instanceUrl = m.Value.TrimEnd('/') + "/";
                        break;
                    }
                }
            }

            // Legacy format: CdsFCBContext was a nested object with Views
            var views2 = (ds["CdsFCBContext"] as JsonObject)?["Views"]?.GetValue<string>() ?? string.Empty;
            if (!string.IsNullOrWhiteSpace(views2))
            {
                var m = Regex.Match(views2, @"https://[^/]+", RegexOptions.IgnoreCase);
                if (m.Success)
                {
                    instanceUrl = m.Value.TrimEnd('/') + "/";
                    break;
                }
            }
        }

        if (string.IsNullOrWhiteSpace(instanceUrl))
        {
            return string.Empty;
        }

        var dataSources = new JsonObject();
        foreach (var ds in native)
        {
            var name = ds["Name"]?.GetValue<string>() ?? string.Empty;
            var entitySetName = ds["EntitySetName"]?.GetValue<string>() ?? string.Empty;
            var logicalName = ds["LogicalName"]?.GetValue<string>() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(entitySetName) || string.IsNullOrWhiteSpace(logicalName))
            {
                continue;
            }

            dataSources[name] = new JsonObject
            {
                ["entitySetName"] = entitySetName,
                ["logicalName"] = logicalName,
            };
        }

        if (dataSources.Count == 0)
        {
            return string.Empty;
        }

        var payload = new JsonObject
        {
            ["default.cds"] = new JsonObject
            {
                ["state"] = "Configured",
                ["instanceUrl"] = instanceUrl,
                ["webApiVersion"] = "v9.0",
                ["environmentVariableName"] = string.Empty,
                ["dataSources"] = dataSources,
            },
        };

        return payload.ToJsonString();
    }

    private static void NormalizeDataSourceMetadata(Dictionary<string, byte[]> entries)
    {
        if (!entries.TryGetValue("References/DataSources.json", out var bytes))
        {
            return;
        }

        if (JsonNode.Parse(bytes) is not JsonObject root || root["DataSources"] is not JsonArray dataSources)
        {
            return;
        }

        var changed = false;
        foreach (var ds in dataSources.OfType<JsonObject>())
        {
            var type = ds["Type"]?.GetValue<string>() ?? string.Empty;
            var name = ds["Name"]?.GetValue<string>() ?? string.Empty;

            if (string.Equals(type, "NativeCDSDataSourceInfo", StringComparison.OrdinalIgnoreCase)
                && ds["MaxGetRowsCount"] is null)
            {
                ds["MaxGetRowsCount"] = 500;
                changed = true;
            }

            if (string.Equals(type, "StaticDataSourceInfo", StringComparison.OrdinalIgnoreCase)
                && name.EndsWith("Sample", StringComparison.OrdinalIgnoreCase)
                && !(ds["IsSampleData"]?.GetValue<bool>() ?? false))
            {
                ds["IsSampleData"] = true;
                changed = true;
            }
        }

        if (!changed)
        {
            return;
        }

        root["DataSources"] = dataSources;
        entries["References/DataSources.json"] = Encoding.UTF8.GetBytes(root.ToJsonString(JsonOptions));
    }

    private static string ResolveComponentTemplateName(string componentName, JsonObject template, Dictionary<string, JsonObject> metadataByName)
    {
        if (metadataByName.TryGetValue(componentName, out var meta))
        {
            return meta["TemplateName"]?.GetValue<string>() ?? template["Name"]?.GetValue<string>() ?? Guid.NewGuid().ToString("N");
        }

        return template["Name"]?.GetValue<string>() ?? Guid.NewGuid().ToString("N");
    }

    private static void ReplaceEntries(Dictionary<string, byte[]> entries, string folderPrefix, Dictionary<string, JsonObject> replacement)
    {
        var keys = entries.Keys.Where(k => k.StartsWith(folderPrefix, StringComparison.OrdinalIgnoreCase) && k.EndsWith(".json", StringComparison.OrdinalIgnoreCase)).ToList();
        foreach (var k in keys)
        {
            entries.Remove(k);
        }

        foreach (var (k, v) in replacement)
        {
            entries[k] = Encoding.UTF8.GetBytes(v.ToJsonString(JsonOptions));
        }
    }

    private static void UpdateUsedTemplates(
        Dictionary<string, byte[]> entries,
        IReadOnlyDictionary<string, JsonObject> topControlFiles,
        IReadOnlyDictionary<string, JsonObject> topComponentFiles)
    {
        var excluded = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "appinfo",
            "hostControl",
            "screen",
            "galleryTemplate",
        };

        var catalog = new Dictionary<string, UsedTemplate>(StringComparer.OrdinalIgnoreCase);
        var pcfCatalog = new Dictionary<string, JsonObject>(StringComparer.OrdinalIgnoreCase);
        void RegisterCatalogEntry(UsedTemplate t)
        {
            if (string.IsNullOrWhiteSpace(t.Name) || string.IsNullOrWhiteSpace(t.TemplateXml))
            {
                return;
            }

            var exactKey = $"{t.Name}|{t.Version}";
            if (!catalog.ContainsKey(exactKey))
            {
                catalog[exactKey] = t;
            }

            if (!catalog.TryGetValue(t.Name, out var existing)
                || SemverTuple(t.Version).CompareTo(SemverTuple(existing.Version)) > 0)
            {
                catalog[t.Name] = t;
            }
        }

        void RegisterPcfCatalogEntries(IReadOnlyList<JsonObject> templates)
        {
            foreach (var t in templates)
            {
                var name = t["Name"]?.GetValue<string>() ?? string.Empty;
                if (string.IsNullOrWhiteSpace(name))
                {
                    continue;
                }

                var version = t["Version"]?.GetValue<string>() ?? string.Empty;
                if (!pcfCatalog.TryGetValue(name, out var existing))
                {
                    pcfCatalog[name] = (JsonObject)t.DeepClone();
                    continue;
                }

                var existingVersion = existing["Version"]?.GetValue<string>() ?? string.Empty;
                if (SemverTuple(version).CompareTo(SemverTuple(existingVersion)) > 0)
                {
                    pcfCatalog[name] = (JsonObject)t.DeepClone();
                }
            }
        }

        foreach (var t in ReadUsedTemplates(entries))
        {
            RegisterCatalogEntry(t);
        }

        RegisterPcfCatalogEntries(ReadPcfTemplates(entries));

        ReadEmbeddedAllControlsEntries(out var embeddedEntries);
        foreach (var t in ReadUsedTemplates(embeddedEntries))
        {
            RegisterCatalogEntry(t);
        }

        RegisterPcfCatalogEntries(ReadPcfTemplates(embeddedEntries));

        var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var seenPcf = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var used = new List<UsedTemplate>();
        var usedPcf = new List<JsonObject>();

        void CollectFromTop(JsonObject top)
        {
            foreach (var node in Flatten(top))
            {
                var template = node["Template"] as JsonObject;
                var name = template?["Name"]?.GetValue<string>() ?? string.Empty;
                var version = template?["Version"]?.GetValue<string>() ?? string.Empty;
                if (string.IsNullOrWhiteSpace(name) || excluded.Contains(name))
                {
                    continue;
                }

                var seenKey = $"{name}|{version}";
                if (!seen.Add(seenKey))
                {
                    continue;
                }

                if (catalog.TryGetValue(seenKey, out var exact))
                {
                    used.Add(exact);
                    continue;
                }

                if (pcfCatalog.TryGetValue(name, out var pcfByName))
                {
                    if (seenPcf.Add(name))
                    {
                        var pcf = (JsonObject)pcfByName.DeepClone();
                        if (!string.IsNullOrWhiteSpace(version))
                        {
                            pcf["Version"] = version;
                        }

                        usedPcf.Add(pcf);
                    }

                    continue;
                }

                if (catalog.TryGetValue(name, out var byName))
                {
                    used.Add(string.IsNullOrWhiteSpace(version)
                        ? byName
                        : byName with { Version = version });
                }
            }
        }

        foreach (var top in topControlFiles.Values.Select(v => v["TopParent"] as JsonObject).Where(v => v is not null).Cast<JsonObject>())
        {
            CollectFromTop(top);
        }

        foreach (var top in topComponentFiles.Values.Select(v => v["TopParent"] as JsonObject).Where(v => v is not null).Cast<JsonObject>())
        {
            CollectFromTop(top);
        }

        if (!entries.TryGetValue("References/Templates.json", out var templatesBytes)
            || JsonNode.Parse(templatesBytes) is not JsonObject templatesRoot)
        {
            templatesRoot = new JsonObject();
        }

        var usedTemplatesNode = new JsonArray();
        foreach (var t in used)
        {
            if (string.IsNullOrWhiteSpace(t.TemplateXml))
            {
                continue;
            }

            usedTemplatesNode.Add(new JsonObject
            {
                ["Name"] = t.Name,
                ["Version"] = t.Version,
                ["Template"] = t.TemplateXml,
            });
        }

        templatesRoot["UsedTemplates"] = usedTemplatesNode;
        if (usedPcf.Count > 0)
        {
            var pcfTemplatesNode = new JsonArray();
            foreach (var pcf in usedPcf.OrderBy(p => p["Name"]?.GetValue<string>() ?? string.Empty, StringComparer.OrdinalIgnoreCase))
            {
                pcfTemplatesNode.Add(pcf);
            }

            templatesRoot["PcfTemplates"] = pcfTemplatesNode;
        }
        else
        {
            templatesRoot.Remove("PcfTemplates");
        }

        entries["References/Templates.json"] = Encoding.UTF8.GetBytes(templatesRoot.ToJsonString(JsonOptions));
    }

    private sealed record GalleryTemplateDescriptor(string Id, string Name, string Version, HashSet<string> Properties);

    private static void ApplyLegacyControlParityTransforms(
        Dictionary<string, JsonObject> topControlFiles,
        Dictionary<string, JsonObject> topComponentFiles,
        GalleryTemplateDescriptor? galleryTemplate)
    {
        foreach (var top in topControlFiles.Values
                     .Select(v => v["TopParent"] as JsonObject)
                     .Where(v => v is not null)
                     .Cast<JsonObject>())
        {
            ApplyLegacyControlParityTransformsToNode(top, galleryTemplate);
        }

        foreach (var top in topComponentFiles.Values
                     .Select(v => v["TopParent"] as JsonObject)
                     .Where(v => v is not null)
                     .Cast<JsonObject>())
        {
            ApplyLegacyControlParityTransformsToNode(top, galleryTemplate);
        }
    }

    private static void ApplyLegacyControlParityTransformsToNode(JsonObject node, GalleryTemplateDescriptor? galleryTemplate)
    {
        var children = (node["Children"] as JsonArray) ?? new JsonArray();
        foreach (var child in children.OfType<JsonObject>())
        {
            ApplyLegacyControlParityTransformsToNode(child, galleryTemplate);
        }

        ApplyGalleryTemplateTransform(node, galleryTemplate);
        FlattenGroupControls(node);
        ReindexChildren(node);
    }

    private static void ApplyGalleryTemplateTransform(JsonObject galleryNode, GalleryTemplateDescriptor? descriptor)
    {
        if (descriptor is null)
        {
            return;
        }

        var templateName = galleryNode["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
        if (!string.Equals(templateName, "gallery", StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        var children = (galleryNode["Children"] as JsonArray) ?? new JsonArray();
        galleryNode["Children"] = children;

        JsonObject? galleryTemplateChild = null;
        var existingTemplateChildren = new List<JsonObject>();
        foreach (var child in children.OfType<JsonObject>())
        {
            var childTemplate = child["Template"] as JsonObject;
            var childTemplateName = childTemplate?["Name"]?.GetValue<string>() ?? string.Empty;
            var childTemplateId = childTemplate?["Id"]?.GetValue<string>() ?? string.Empty;
            var isGalleryTemplate = string.Equals(childTemplateName, descriptor.Name, StringComparison.OrdinalIgnoreCase)
                                    || string.Equals(childTemplateId, descriptor.Id, StringComparison.OrdinalIgnoreCase);
            if (!isGalleryTemplate)
            {
                continue;
            }

            existingTemplateChildren.Add(child);
            galleryTemplateChild ??= child;
        }

        if (galleryTemplateChild is null)
        {
            var galleryName = galleryNode["Name"]?.GetValue<string>() ?? "Gallery";
            var preservedTemplateName = galleryNode["__PreservedGalleryTemplateName"]?.GetValue<string>() ?? string.Empty;
            var preservedTemplateId = galleryNode["__PreservedGalleryTemplateControlUniqueId"]?.GetValue<string>() ?? string.Empty;
            var preservedTemplatePublishOrder = galleryNode["__PreservedGalleryTemplatePublishOrderIndex"]?.GetValue<int?>();
            galleryTemplateChild = CreateDefaultControl(
                string.IsNullOrWhiteSpace(preservedTemplateName)
                    ? NextGalleryTemplateName(children)
                    : preservedTemplateName);
            galleryTemplateChild["Parent"] = galleryName;
            galleryTemplateChild["IsDataControl"] = true;
            galleryTemplateChild["StyleName"] = string.Empty;
            galleryTemplateChild["HasDynamicProperties"] = false;
            if (!string.IsNullOrWhiteSpace(preservedTemplateId))
            {
                galleryTemplateChild["ControlUniqueId"] = preservedTemplateId;
            }

            if (preservedTemplatePublishOrder is not null)
            {
                galleryTemplateChild["PublishOrderIndex"] = preservedTemplatePublishOrder;
            }

            galleryTemplateChild["Template"] = new JsonObject
            {
                ["Id"] = descriptor.Id,
                ["Version"] = descriptor.Version,
                ["LastModifiedTimestamp"] = "0",
                ["Name"] = descriptor.Name,
                ["FirstParty"] = true,
                ["IsPremiumPcfControl"] = false,
                ["IsCustomGroupControlTemplate"] = false,
                ["CustomGroupControlTemplateName"] = string.Empty,
                ["IsComponentDefinition"] = false,
                ["OverridableProperties"] = new JsonObject(),
            };

            children.Insert(0, galleryTemplateChild);
        }

        for (var i = existingTemplateChildren.Count - 1; i >= 0; i--)
        {
            var extra = existingTemplateChildren[i];
            if (ReferenceEquals(extra, galleryTemplateChild))
            {
                continue;
            }

            children.Remove(extra);
        }

        var parentRules = (galleryNode["Rules"] as JsonArray) ?? new JsonArray();
        var childRules = (galleryTemplateChild["Rules"] as JsonArray) ?? new JsonArray();

        var moved = new List<JsonObject>();
        foreach (var rule in parentRules.OfType<JsonObject>())
        {
            var property = rule["Property"]?.GetValue<string>() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(property) || !descriptor.Properties.Contains(property))
            {
                continue;
            }

            moved.Add(rule);
        }

        if (moved.Count > 0)
        {
            foreach (var rule in moved)
            {
                parentRules.Remove(rule);

                var property = rule["Property"]?.GetValue<string>() ?? string.Empty;
                var existing = childRules
                    .OfType<JsonObject>()
                    .FirstOrDefault(r => string.Equals(r["Property"]?.GetValue<string>() ?? string.Empty, property, StringComparison.OrdinalIgnoreCase));

                if (existing is not null)
                {
                    childRules.Remove(existing);
                }

                childRules.Add(rule);
            }
        }

        galleryNode["Rules"] = parentRules;
        galleryTemplateChild["Rules"] = childRules;

        UpdateControlPropertyStateFromRules(galleryNode);
        UpdateControlPropertyStateFromRules(galleryTemplateChild);

        children.Remove(galleryTemplateChild);
        children.Insert(0, galleryTemplateChild);
        galleryNode.Remove("__PreservedGalleryTemplateName");
        galleryNode.Remove("__PreservedGalleryTemplateControlUniqueId");
        galleryNode.Remove("__PreservedGalleryTemplatePublishOrderIndex");
    }

    private static string NextGalleryTemplateName(JsonArray siblings)
    {
        var used = new HashSet<string>(siblings
            .OfType<JsonObject>()
            .Select(s => s["Name"]?.GetValue<string>() ?? string.Empty)
            .Where(n => !string.IsNullOrWhiteSpace(n)), StringComparer.OrdinalIgnoreCase);

        var i = 1;
        while (used.Contains($"galleryTemplate{i}"))
        {
            i++;
        }

        return $"galleryTemplate{i}";
    }

    private static void FlattenGroupControls(JsonObject parentNode)
    {
        var parentName = parentNode["Name"]?.GetValue<string>() ?? string.Empty;
        var children = (parentNode["Children"] as JsonArray) ?? new JsonArray();
        if (children.Count == 0)
        {
            parentNode["Children"] = children;
            return;
        }

        var rewrittenChildren = new JsonArray();
        var liftedChildren = new List<JsonObject>();

        foreach (var child in children.OfType<JsonObject>())
        {
            var childClone = (JsonObject)child.DeepClone();
            var templateName = child["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
            var isGroup = string.Equals(templateName, "group", StringComparison.OrdinalIgnoreCase)
                          || (child["IsGroupControl"]?.GetValue<bool>() ?? false);

            if (!isGroup)
            {
                rewrittenChildren.Add(childClone);
                continue;
            }

            var grouped = (child["Children"] as JsonArray) ?? new JsonArray();
            if (grouped.Count == 0)
            {
                rewrittenChildren.Add(childClone);
                continue;
            }

            var groupedNames = new JsonArray();
            foreach (var groupedChild in grouped.OfType<JsonObject>())
            {
                var groupedClone = (JsonObject)groupedChild.DeepClone();
                var groupedName = groupedChild["Name"]?.GetValue<string>() ?? string.Empty;
                if (!string.IsNullOrWhiteSpace(groupedName))
                {
                    groupedNames.Add(groupedName);
                }

                groupedClone["Parent"] = parentName;
                liftedChildren.Add(groupedClone);
            }

            childClone["IsGroupControl"] = true;
            childClone["GroupedControlsKey"] = groupedNames;
            childClone["Children"] = new JsonArray();
            rewrittenChildren.Add(childClone);
        }

        foreach (var lifted in liftedChildren)
        {
            rewrittenChildren.Add(lifted);
        }

        parentNode["Children"] = rewrittenChildren;
    }

    private static void ReindexChildren(JsonObject parentNode)
    {
        var children = (parentNode["Children"] as JsonArray) ?? new JsonArray();
        for (var i = 0; i < children.Count; i++)
        {
            if (children[i] is not JsonObject child)
            {
                continue;
            }

            if (child["Index"] is null)
            {
                child["Index"] = i;
            }

            if (child["PublishOrderIndex"] is null)
            {
                child["PublishOrderIndex"] = child["Index"]?.GetValue<int>() ?? i;
            }
        }

        parentNode["Children"] = children;
    }

    private static void UpdateControlPropertyStateFromRules(JsonObject controlNode)
    {
        var rules = (controlNode["Rules"] as JsonArray) ?? new JsonArray();
        var desired = new List<string>();
        foreach (var rule in rules.OfType<JsonObject>())
        {
            var property = rule["Property"]?.GetValue<string>() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(property))
            {
                continue;
            }

            if (!desired.Contains(property, StringComparer.OrdinalIgnoreCase))
            {
                desired.Add(property);
            }
        }

        var existingByProperty = new Dictionary<string, JsonNode>(StringComparer.OrdinalIgnoreCase);
        var existingOrder = new List<string>();
        foreach (var stateEntry in ((controlNode["ControlPropertyState"] as JsonArray) ?? new JsonArray()))
        {
            var property = GetStatePropertyName(stateEntry);
            if (string.IsNullOrWhiteSpace(property))
            {
                continue;
            }

            if (!existingByProperty.ContainsKey(property))
            {
                existingByProperty[property] = stateEntry?.DeepClone() ?? JsonValue.Create(property)!;
            }

            if (!existingOrder.Contains(property, StringComparer.OrdinalIgnoreCase))
            {
                existingOrder.Add(property);
            }
        }

        var ordered = new List<string>();
        foreach (var property in existingOrder)
        {
            if (desired.Contains(property, StringComparer.OrdinalIgnoreCase)
                && !ordered.Contains(property, StringComparer.OrdinalIgnoreCase))
            {
                ordered.Add(property);
            }
        }

        foreach (var property in desired)
        {
            if (!ordered.Contains(property, StringComparer.OrdinalIgnoreCase))
            {
                ordered.Add(property);
            }
        }

        var state = new JsonArray();
        foreach (var property in ordered)
        {
            if (existingByProperty.TryGetValue(property, out var existingNode)
                && existingNode is JsonObject)
            {
                state.Add(existingNode.DeepClone());
                continue;
            }

            if (IsAppInfoControl(controlNode)
                && (string.Equals(property, "OnStart", StringComparison.OrdinalIgnoreCase)
                    || string.Equals(property, "StartScreen", StringComparison.OrdinalIgnoreCase)))
            {
                state.Add(CreateInvariantPropertyStateEntry(property));
                continue;
            }

            state.Add(property);
        }

        controlNode["ControlPropertyState"] = state;
    }

    private static string GetStatePropertyName(JsonNode? stateEntry)
    {
        if (stateEntry is null)
        {
            return string.Empty;
        }

        if (stateEntry is JsonValue value)
        {
            return value.GetValue<string>() ?? string.Empty;
        }

        if (stateEntry is JsonObject obj)
        {
            return obj["InvariantPropertyName"]?.GetValue<string>()
                   ?? obj["Property"]?.GetValue<string>()
                   ?? string.Empty;
        }

        return string.Empty;
    }

    private static bool IsAppInfoControl(JsonObject controlNode)
    {
        var templateName = controlNode["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
        var templateId = controlNode["Template"]?["Id"]?.GetValue<string>() ?? string.Empty;
        return string.Equals(templateName, "appinfo", StringComparison.OrdinalIgnoreCase)
               || templateId.EndsWith("/appinfo", StringComparison.OrdinalIgnoreCase);
    }

    private static JsonObject CreateInvariantPropertyStateEntry(string property)
    {
        return new JsonObject
        {
            ["InvariantPropertyName"] = property,
            ["AutoRuleBindingEnabled"] = false,
            ["AutoRuleBindingString"] = "",
            ["NameMapSourceSchema"] = "?",
            ["IsLockable"] = false,
            ["AFDDataSourceName"] = "",
        };
    }

    private static GalleryTemplateDescriptor? BuildGalleryTemplateDescriptor(Dictionary<string, byte[]> entries)
    {
        static GalleryTemplateDescriptor Fallback()
            => new("http://microsoft.com/appmagic/galleryTemplate", "galleryTemplate", "1.0", new HashSet<string>(StringComparer.OrdinalIgnoreCase));

        if (!entries.TryGetValue("References/Templates.json", out var templatesBytes))
        {
            return Fallback();
        }

        var templatesRoot = JsonNode.Parse(templatesBytes)?.AsObject();
        var usedTemplates = templatesRoot?["UsedTemplates"] as JsonArray;
        if (usedTemplates is null)
        {
            return Fallback();
        }

        var gallery = usedTemplates
            .OfType<JsonObject>()
            .FirstOrDefault(t => string.Equals(t["Name"]?.GetValue<string>() ?? string.Empty, "gallery", StringComparison.OrdinalIgnoreCase));
        if (gallery is null)
        {
            return Fallback();
        }

        var templateXml = gallery["Template"]?.GetValue<string>() ?? string.Empty;
        if (string.IsNullOrWhiteSpace(templateXml))
        {
            return Fallback();
        }

        try
        {
            var doc = XDocument.Parse(templateXml);
            var nested = doc.Descendants().FirstOrDefault(e => e.Name.LocalName == "dataControlWidget"
                                                               && string.Equals(e.Attribute("name")?.Value, "galleryTemplate", StringComparison.OrdinalIgnoreCase));
            if (nested is null)
            {
                return null;
            }

            var id = nested.Attribute("id")?.Value ?? "http://microsoft.com/appmagic/galleryTemplate";
            var name = nested.Attribute("name")?.Value ?? "galleryTemplate";
            var version = nested.Attribute("version")?.Value ?? "1.0";

            var properties = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            foreach (var prop in nested.Descendants().Where(e => e.Name.LocalName is "property" or "includeProperty" or "overrideProperty"))
            {
                var propName = prop.Attribute("name")?.Value;
                if (!string.IsNullOrWhiteSpace(propName))
                {
                    properties.Add(propName);
                }
            }

            return new GalleryTemplateDescriptor(id, name, version, properties);
        }
        catch
        {
            return Fallback();
        }
    }

    private static void UpdateEditorState(
        Dictionary<string, byte[]> entries,
        ISerializer serializer,
        IDeserializer deserializer,
        List<string> screenOrderFromFiles,
        List<string> componentOrderFromFiles,
        List<string> discoveredScreens,
        List<string> discoveredComponents)
    {
        var hadExistingEditorState = entries.TryGetValue("Src/_EditorState.pa.yaml", out var existingBytes);
        var existingScreensOrder = new List<string>();
        var existingComponentsOrder = new List<string>();
        if (hadExistingEditorState)
        {
            var text = Encoding.UTF8.GetString(existingBytes!);
            if (TryParseYamlMap(deserializer, text, out var root)
                && TryGetMap(root, "EditorState", out var editor))
            {
                if (editor.TryGetValue("ScreensOrder", out var so) && so is List<object?> sl)
                {
                    existingScreensOrder.AddRange(sl.Select(v => v?.ToString() ?? string.Empty).Where(v => !string.IsNullOrWhiteSpace(v)));
                }

                if (editor.TryGetValue("ComponentDefinitionsOrder", out var co) && co is List<object?> cl)
                {
                    existingComponentsOrder.AddRange(cl.Select(v => v?.ToString() ?? string.Empty).Where(v => !string.IsNullOrWhiteSpace(v)));
                }
            }
        }

        var mergedScreens = MergeOrder(existingScreensOrder, screenOrderFromFiles, discoveredScreens);
        var mergedComponents = MergeOrder(existingComponentsOrder, componentOrderFromFiles, discoveredComponents);

        if (hadExistingEditorState
            && mergedScreens.SequenceEqual(existingScreensOrder, StringComparer.OrdinalIgnoreCase)
            && mergedComponents.SequenceEqual(existingComponentsOrder, StringComparer.OrdinalIgnoreCase))
        {
            entries["Src/_EditorState.pa.yaml"] = existingBytes!;
            return;
        }

        var payload = new Dictionary<string, object?>
        {
            ["EditorState"] = new Dictionary<string, object?>
            {
                ["ScreensOrder"] = mergedScreens,
            },
        };

        if (mergedComponents.Count > 0
            && payload["EditorState"] is Dictionary<string, object?> editorState)
        {
            editorState["ComponentDefinitionsOrder"] = mergedComponents;
        }

        var yaml = string.Join(Environment.NewLine, HeaderLines) + Environment.NewLine + serializer.Serialize(payload);
        entries["Src/_EditorState.pa.yaml"] = Encoding.UTF8.GetBytes(yaml);
    }

    private static List<string> MergeOrder(List<string> existing, List<string> fromFiles, List<string> discovered)
    {
        var result = new List<string>();
        void AddIfValid(string value)
        {
            if (string.IsNullOrWhiteSpace(value))
            {
                return;
            }

            if (!discovered.Contains(value, StringComparer.OrdinalIgnoreCase))
            {
                return;
            }

            if (!result.Contains(value, StringComparer.OrdinalIgnoreCase))
            {
                result.Add(value);
            }
        }

        foreach (var e in existing) AddIfValid(e);
        foreach (var f in fromFiles) AddIfValid(f);
        foreach (var d in discovered) AddIfValid(d);
        return result;
    }

    private static Dictionary<string, JsonObject> ReadComponentMetadata(Dictionary<string, byte[]> entries)
    {
        var map = new Dictionary<string, JsonObject>(StringComparer.OrdinalIgnoreCase);
        if (!entries.TryGetValue("ComponentsMetadata.json", out var bytes))
        {
            return map;
        }

        var root = JsonNode.Parse(bytes)?.AsObject();
        var arr = root?["Components"] as JsonArray;
        if (arr is null)
        {
            return map;
        }

        foreach (var c in arr.OfType<JsonObject>())
        {
            var name = c["Name"]?.GetValue<string>() ?? string.Empty;
            if (!string.IsNullOrWhiteSpace(name))
            {
                map[name] = c;
            }
        }

        return map;
    }

    private static void UpdateComponentMetadata(Dictionary<string, byte[]> entries, Dictionary<string, Dictionary<object, object?>> componentPayloads, Dictionary<string, JsonObject> topComponentFiles)
    {
        var hadComponentsMetadata = entries.ContainsKey("ComponentsMetadata.json");
        var existing = ReadComponentMetadata(entries);
        var components = new JsonArray();

        foreach (var name in componentPayloads.Keys.OrderBy(x => x, StringComparer.OrdinalIgnoreCase))
        {
            var payload = componentPayloads[name];
            var top = topComponentFiles.Values.FirstOrDefault(v => string.Equals(v["TopParent"]?["Name"]?.GetValue<string>(), name, StringComparison.OrdinalIgnoreCase));
            var topParent = top?["TopParent"] as JsonObject;
            var templateName = topParent?["Template"]?["Name"]?.GetValue<string>()
                ?? (existing.TryGetValue(name, out var old) ? old["TemplateName"]?.GetValue<string>() : null)
                ?? Guid.NewGuid().ToString("N");

            var allowCustomization = payload.TryGetValue("AllowCustomization", out var ac) && bool.TryParse(ac?.ToString(), out var acBool) ? acBool : true;
            var allowAccessToGlobals = payload.TryGetValue("AccessAppScope", out var aa) && bool.TryParse(aa?.ToString(), out var aaBool) && aaBool;
            var description = payload.TryGetValue("Description", out var d) ? d?.ToString() ?? string.Empty : string.Empty;

            components.Add(new JsonObject
            {
                ["Name"] = name,
                ["TemplateName"] = templateName,
                ["Description"] = description,
                ["AllowCustomization"] = allowCustomization,
                ["AllowAccessToGlobals"] = allowAccessToGlobals,
            });
        }

        if (components.Count == 0 && !hadComponentsMetadata)
        {
            // Preserve Studio behavior: do not introduce ComponentsMetadata.json for apps without components.
            return;
        }

        entries["ComponentsMetadata.json"] = Encoding.UTF8.GetBytes(new JsonObject
        {
            ["Components"] = components,
        }.ToJsonString(JsonOptions));
    }

    private static void UpdatePropertiesControlCount(
        Dictionary<string, byte[]> entries,
        IReadOnlyDictionary<string, JsonObject> topControlFiles,
        IReadOnlyDictionary<string, JsonObject> topComponentFiles)
    {
        if (!entries.TryGetValue("Properties.json", out var bytes))
        {
            return;
        }

        var root = JsonNode.Parse(bytes)?.AsObject();
        if (root is null)
        {
            return;
        }

        var computedCounts = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);

        void CountNode(JsonObject node)
        {
            var templateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
            if (!string.IsNullOrWhiteSpace(templateName)
                && !string.Equals(templateName, "appinfo", StringComparison.OrdinalIgnoreCase)
                && !string.Equals(templateName, "hostControl", StringComparison.OrdinalIgnoreCase))
            {
                computedCounts[templateName] = computedCounts.TryGetValue(templateName, out var c) ? c + 1 : 1;
            }

            foreach (var child in (node["Children"] as JsonArray ?? new JsonArray()).OfType<JsonObject>())
            {
                CountNode(child);
            }
        }

        foreach (var top in topControlFiles.Values.Select(v => v["TopParent"] as JsonObject).Where(v => v is not null).Cast<JsonObject>())
        {
            CountNode(top);
        }

        foreach (var top in topComponentFiles.Values.Select(v => v["TopParent"] as JsonObject).Where(v => v is not null).Cast<JsonObject>())
        {
            CountNode(top);
        }

        var controlCountNode = new JsonObject();
        var existingOrder = (root["ControlCount"] as JsonObject)
            ?.Select(kv => kv.Key)
            .ToList()
            ?? [];

        foreach (var key in existingOrder)
        {
            if (!computedCounts.TryGetValue(key, out var value))
            {
                continue;
            }

            controlCountNode[key] = value;
        }

        foreach (var kv in computedCounts)
        {
            if (controlCountNode.ContainsKey(kv.Key))
            {
                continue;
            }

            controlCountNode[kv.Key] = kv.Value;
        }

        root["ControlCount"] = controlCountNode;
        entries["Properties.json"] = Encoding.UTF8.GetBytes(root.ToJsonString(JsonOptions));
    }

    private static void UpsertProperties(JsonObject control, Dictionary<object, object?> yamlProps)
    {
        var rules = (control["Rules"] as JsonArray) ?? new JsonArray();
        var byProperty = rules.OfType<JsonObject>()
            .Where(r => !string.IsNullOrWhiteSpace(r["Property"]?.GetValue<string>()))
            .ToDictionary(r => r["Property"]!.GetValue<string>(), r => r, StringComparer.OrdinalIgnoreCase);

        foreach (var (k, v) in yamlProps)
        {
            var property = k?.ToString() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(property))
            {
                continue;
            }

            if (!byProperty.TryGetValue(property, out var rule))
            {
                rule = new JsonObject
                {
                    ["Property"] = property,
                    ["Category"] = InferCategory(property),
                    ["RuleProviderType"] = "Unknown",
                };
                rules.Add(rule);
            }

            rule["InvariantScript"] = StripFormula(v?.ToString() ?? string.Empty);
        }

        control["Rules"] = rules;
        UpdateControlPropertyStateFromRules(control);
    }

    private static void ApplyFromYaml(
        JsonObject node,
        Dictionary<object, object?> payload,
        string parentName,
        Dictionary<string, JsonObject> allExistingNodes,
        ControlIdAllocator idAllocator,
        TemplateResolver templateResolver,
        ControlMetadataResolver metadataResolver,
        TemplatePropertyResolver propertyResolver,
        TemplateKeywordResolver keywordResolver,
        IReadOnlyDictionary<string, bool>? appFlags = null,
        IReadOnlyDictionary<string, IReadOnlyList<TemplateAppFlagRequirement>>? flagRequirementsMap = null)
    {
        if (payload.TryGetValue("Control", out var ct))
        {
            ApplyTemplateFromControlType(node, ct?.ToString() ?? string.Empty, templateResolver, metadataResolver);
        }

        // Ensure template defaults are applied even when a YAML node omits `Control`
        // (for example top-level screen nodes). This materializes expected baseline
        // properties like Width/Height/LoadingSpinner for screens.
        var currentTemplateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
        var currentTemplateId = node["Template"]?["Id"]?.GetValue<string>() ?? string.Empty;
        if (!string.IsNullOrWhiteSpace(currentTemplateName) || !string.IsNullOrWhiteSpace(currentTemplateId))
        {
            metadataResolver.ApplyTemplateDefaults(node, currentTemplateName, currentTemplateId);
        }

        ValidateRequiredKeywordsFromTemplate(node, payload, keywordResolver);

        if (payload.TryGetValue("Variant", out var variant))
        {
            var requestedVariant = variant?.ToString() ?? string.Empty;
            var existingVariant = node["VariantName"]?.GetValue<string>() ?? string.Empty;
            var keepExistingAliasMapping = !string.IsNullOrWhiteSpace(existingVariant)
                                           && (string.Equals(requestedVariant, "AutoLayout", StringComparison.OrdinalIgnoreCase)
                                               || string.Equals(requestedVariant, "ManualLayout", StringComparison.OrdinalIgnoreCase));

            if (!keepExistingAliasMapping)
            {
                node["VariantName"] = requestedVariant;
            }
        }

        if (payload.TryGetValue("IsLocked", out var isLocked) && bool.TryParse(isLocked?.ToString(), out var l))
        {
            node["IsLocked"] = l;
        }

        if (payload.TryGetValue("Properties", out var propsObj) && propsObj is Dictionary<object, object?> props)
        {
            ValidatePropertiesAgainstTemplate(node, props, propertyResolver);
            if (appFlags is not null && flagRequirementsMap is not null)
            {
                EnforceAppFlagRequirements(node, appFlags, flagRequirementsMap);
            }
            ReplaceProperties(node, props, metadataResolver);
        }

        // Preserve existing style metadata for parity; avoid forcing default styles.

        if (payload.TryGetValue("Children", out var childrenObj) && childrenObj is List<object?> children)
        {
            var nodeTemplateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;

            var existingChildren = ((node["Children"] as JsonArray) ?? new JsonArray())
                .OfType<JsonObject>()
                .ToList();

            var yamlChildNames = children
                .OfType<Dictionary<object, object?>>()
                .Where(singleton => singleton.Count == 1)
                .Select(singleton => singleton.First().Key?.ToString() ?? string.Empty)
                .Where(name => !string.IsNullOrWhiteSpace(name))
                .ToList();

            if (string.Equals(nodeTemplateName, "screen", StringComparison.OrdinalIgnoreCase)
                && existingChildren.Count > 0
                && yamlChildNames.Count > 0)
            {
                var existingChildNames = existingChildren
                    .Select(c => c["Name"]?.GetValue<string>() ?? string.Empty)
                    .Where(name => !string.IsNullOrWhiteSpace(name))
                    .ToHashSet(StringComparer.OrdinalIgnoreCase);

                var hasAnyOverlap = yamlChildNames.Any(existingChildNames.Contains);
                if (!hasAnyOverlap)
                {
                    // If YAML child names do not overlap at all with existing screen children,
                    // preserve the original tree to avoid destructive topology conversion.
                    node["Children"] = new JsonArray(existingChildren.Select(c => (JsonNode)c.DeepClone()).ToArray());
                    return;
                }
            }

            if (string.Equals(nodeTemplateName, "gallery", StringComparison.OrdinalIgnoreCase))
            {
                var existingGalleryTemplate = ((node["Children"] as JsonArray) ?? new JsonArray())
                    .OfType<JsonObject>()
                    .FirstOrDefault(c => string.Equals(c["Template"]?["Name"]?.GetValue<string>() ?? string.Empty, "galleryTemplate", StringComparison.OrdinalIgnoreCase)
                                         || string.Equals(c["Template"]?["Id"]?.GetValue<string>() ?? string.Empty, "http://microsoft.com/appmagic/galleryTemplate", StringComparison.OrdinalIgnoreCase));

                if (existingGalleryTemplate is not null)
                {
                    var existingGalleryTemplateName = existingGalleryTemplate["Name"]?.GetValue<string>() ?? string.Empty;
                    if (!string.IsNullOrWhiteSpace(existingGalleryTemplateName))
                    {
                        node["__PreservedGalleryTemplateName"] = existingGalleryTemplateName;
                    }

                    var existingGalleryTemplateControlUniqueId = existingGalleryTemplate["ControlUniqueId"]?.GetValue<string>() ?? string.Empty;
                    if (!string.IsNullOrWhiteSpace(existingGalleryTemplateControlUniqueId))
                    {
                        node["__PreservedGalleryTemplateControlUniqueId"] = existingGalleryTemplateControlUniqueId;
                    }

                    if (existingGalleryTemplate["PublishOrderIndex"] is not null)
                    {
                        node["__PreservedGalleryTemplatePublishOrderIndex"] = existingGalleryTemplate["PublishOrderIndex"]!.DeepClone();
                    }
                }
            }

            var childrenArray = new JsonArray();
            var index = 0;
            foreach (var item in children)
            {
                if (item is not Dictionary<object, object?> singleton || singleton.Count != 1)
                {
                    continue;
                }

                var kv = singleton.First();
                var childName = kv.Key?.ToString() ?? string.Empty;
                if (string.IsNullOrWhiteSpace(childName) || kv.Value is not Dictionary<object, object?> childPayload)
                {
                    continue;
                }

                if (!childPayload.ContainsKey("Control"))
                {
                    throw new InvalidDataException($"Control '{childName}' is missing required 'Control' type in YAML.");
                }

                JsonObject child;
                JsonObject? existingNode = null;
                if (allExistingNodes.TryGetValue(childName, out var existing))
                {
                    child = (JsonObject)existing.DeepClone();
                    existingNode = existing;
                }
                else
                {
                    child = CreateDefaultControl(childName);
                }

                child["Name"] = childName;
                child["Parent"] = parentName;
                if (existingNode is null || child["Index"] is null)
                {
                    child["Index"] = index;
                }

                if (existingNode is null || child["PublishOrderIndex"] is null)
                {
                    child["PublishOrderIndex"] = child["Index"]?.GetValue<int>() ?? index;
                }
                child["ControlUniqueId"] = idAllocator.GetOrCreate(childName, existing: allExistingNodes.TryGetValue(childName, out var old) ? old : null);

                ApplyFromYaml(child, childPayload, childName, allExistingNodes, idAllocator, templateResolver, metadataResolver, propertyResolver, keywordResolver, appFlags, flagRequirementsMap);
                childrenArray.Add(child);
                index++;
            }

            node["Children"] = childrenArray;
        }
        else
        {
            node["Children"] ??= new JsonArray();
        }
    }

    private static void ApplyTemplateFromControlType(JsonObject node, string controlType, TemplateResolver templateResolver, ControlMetadataResolver metadataResolver)
    {
        ValidateSourceControlCompatibility(controlType);

        if (!templateResolver.TryResolve(controlType, out var resolved))
        {
            throw new InvalidDataException($"Could not resolve a template for YAML control type '{controlType}'. Add a matching control template in 'All controls.msapp' (or ensure this app already references it).");
        }

        var oldTemplateId = node["Template"]?["Id"]?.GetValue<string>() ?? string.Empty;
        var oldTemplateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
        var templateChanged = !string.Equals(oldTemplateId, resolved.TemplateId, StringComparison.OrdinalIgnoreCase)
                              || !string.Equals(oldTemplateName, resolved.TemplateName, StringComparison.OrdinalIgnoreCase);

        JsonObject template;
        if (resolved.TemplatePrototype is not null)
        {
            template = (JsonObject)resolved.TemplatePrototype.DeepClone();
        }
        else
        {
            template = (node["Template"] as JsonObject) ?? new JsonObject();
        }

        template["Id"] = resolved.TemplateId;
        template["Name"] = resolved.TemplateName;
        template["Version"] = resolved.Version;
        node["Template"] = template;

        if (templateChanged)
        {
            // Switching template families (for example legacy text -> modern PCF text input)
            // should discard stale rule/state payloads so the target template defaults materialize.
            node["Rules"] = new JsonArray();
            node["ControlPropertyState"] = new JsonArray();
            node.Remove("DynamicProperties");
            node.Remove("HasDynamicProperties");
        }

        metadataResolver.ApplyTemplateDefaults(node, resolved.TemplateName, resolved.TemplateId);
    }

    private static void ReplaceProperties(JsonObject node, Dictionary<object, object?> props, ControlMetadataResolver metadataResolver)
    {
        var existingRulesArray = ((node["Rules"] as JsonArray) ?? new JsonArray())
            .OfType<JsonObject>()
            .Where(r => !string.IsNullOrWhiteSpace(r["Property"]?.GetValue<string>()))
            .ToList();

        var orderedRules = new List<JsonObject>();
        var byProperty = new Dictionary<string, JsonObject>(StringComparer.OrdinalIgnoreCase);
        foreach (var existing in existingRulesArray)
        {
            var clone = (JsonObject)existing.DeepClone();
            var property = clone["Property"]?.GetValue<string>() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(property) || byProperty.ContainsKey(property))
            {
                continue;
            }

            orderedRules.Add(clone);
            byProperty[property] = clone;
        }

        foreach (var (k, v) in props)
        {
            var property = NormalizeSourcePropertyName(node, k?.ToString() ?? string.Empty);
            if (string.IsNullOrWhiteSpace(property))
            {
                continue;
            }

            var inferredCategory = metadataResolver.ResolveCategory(node, property) ?? InferCategory(property);
            var category = inferredCategory;
            JsonObject? oldRule = null;
            if (byProperty.TryGetValue(property, out oldRule))
            {
                var oldCategory = oldRule["Category"]?.GetValue<string>() ?? string.Empty;
                category = string.Equals(oldCategory, "Data", StringComparison.OrdinalIgnoreCase)
                           && !string.Equals(inferredCategory, "Data", StringComparison.OrdinalIgnoreCase)
                    ? inferredCategory
                    : (string.IsNullOrWhiteSpace(oldCategory) ? inferredCategory : oldCategory);

                oldRule["Category"] = category;
                oldRule["InvariantScript"] = StripFormula(v?.ToString() ?? string.Empty);
                oldRule["RuleProviderType"] = oldRule["RuleProviderType"]?.GetValue<string>() ?? "Unknown";
                continue;
            }

            var created = new JsonObject
            {
                ["Property"] = property,
                ["Category"] = category,
                ["InvariantScript"] = StripFormula(v?.ToString() ?? string.Empty),
                ["RuleProviderType"] = oldRule?["RuleProviderType"]?.GetValue<string>()
                    ?? (string.Equals(category, "Behavior", StringComparison.OrdinalIgnoreCase)
                        || string.Equals(category, "OnDemandData", StringComparison.OrdinalIgnoreCase)
                        ? "User"
                        : "Unknown"),
            };

            orderedRules.Add(created);
            byProperty[property] = created;
        }

        var rules = new JsonArray(orderedRules.Select(r => (JsonNode)r).ToArray());
        node["Rules"] = rules;
        UpdateControlPropertyStateFromRules(node);
    }

    private static string InferCategory(string property)
    {
        if (property.StartsWith("On", StringComparison.OrdinalIgnoreCase))
        {
            return "Behavior";
        }

        if (DesignProperties.Contains(property))
        {
            return "Design";
        }

        return "Data";
    }

    private static void EnsureDefaultStyleName(JsonObject node, ControlMetadataResolver metadataResolver)
    {
        var currentStyle = node["StyleName"]?.GetValue<string>() ?? string.Empty;
        if (!string.IsNullOrWhiteSpace(currentStyle))
        {
            return;
        }

        var resolvedStyle = metadataResolver.ResolveStyle(node);
        if (!string.IsNullOrWhiteSpace(resolvedStyle))
        {
            node["StyleName"] = resolvedStyle;
            return;
        }

        var templateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
        var defaultStyle = templateName.ToLowerInvariant() switch
        {
            "screen" => "defaultScreenStyle",
            "label" => "defaultLabelStyle",
            "rectangle" => "defaultRectangleStyle",
            "gallery" => "defaultGalleryStyle",
            "button" => "defaultButtonStyle",
            "slider" => "defaultSliderStyle",
            "datepicker" => "defaultDatePickerStyle",
            _ => string.Empty,
        };

        if (!string.IsNullOrWhiteSpace(defaultStyle))
        {
            node["StyleName"] = defaultStyle;
        }
    }

    private static string StripFormula(string value)
    {
        return value.StartsWith('=') ? value[1..] : value;
    }

    private static TemplateResolver BuildTemplateResolver(Dictionary<string, byte[]> entries, string unpackDirectory)
    {
        var resolver = new TemplateResolver();
        PopulateTemplateResolverFromEntries(entries, resolver);

        ReadEmbeddedAllControlsEntries(out var embeddedEntries);
        PopulateTemplateResolverFromEntries(embeddedEntries, resolver);
        

        return resolver;
    }

    private static ControlMetadataResolver BuildControlMetadataResolver(Dictionary<string, byte[]> entries)
    {
        var resolver = new ControlMetadataResolver();
        PopulateMetadataResolverFromEntries(entries, resolver);

        ReadEmbeddedAllControlsEntries(out var embeddedEntries);
        PopulateMetadataResolverFromEntries(embeddedEntries, resolver);

        return resolver;
    }

    private static TemplatePropertyResolver BuildTemplatePropertyResolver(Dictionary<string, byte[]> entries)
    {
        var resolver = new TemplatePropertyResolver();
        PopulateTemplatePropertyResolverFromEntries(entries, resolver);

        ReadEmbeddedAllControlsEntries(out var embeddedEntries);
        PopulateTemplatePropertyResolverFromEntries(embeddedEntries, resolver);

        return resolver;
    }

    private static TemplateKeywordResolver BuildTemplateKeywordResolver(Dictionary<string, byte[]> entries)
    {
        var resolver = new TemplateKeywordResolver();
        PopulateTemplateKeywordResolverFromEntries(entries, resolver);

        ReadEmbeddedAllControlsEntries(out var embeddedEntries);
        PopulateTemplateKeywordResolverFromEntries(embeddedEntries, resolver);

        return resolver;
    }

    private static void PopulateTemplateKeywordResolverFromEntries(Dictionary<string, byte[]> entries, TemplateKeywordResolver resolver)
    {
        if (!entries.TryGetValue("References/Templates.json", out var templatesBytes))
        {
            return;
        }

        var templatesRoot = JsonNode.Parse(templatesBytes)?.AsObject();
        var usedTemplates = templatesRoot?["UsedTemplates"] as JsonArray;
        if (usedTemplates is null)
        {
            return;
        }

        foreach (var t in usedTemplates.OfType<JsonObject>())
        {
            var name = t["Name"]?.GetValue<string>() ?? string.Empty;
            var id = t["Id"]?.GetValue<string>() ?? string.Empty;
            var templateXml = t["Template"]?.GetValue<string>() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(name))
            {
                continue;
            }

            if (string.IsNullOrWhiteSpace(id))
            {
                id = ParseTemplateId(templateXml);
            }

            resolver.RegisterTemplateKeywords(name, id, ParseRequiredYamlKeywords(templateXml));
        }

        var topParents = ParseTopParentFiles(entries, "Controls/")
            .Concat(ParseTopParentFiles(entries, "Components/"))
            .Select(kv => kv.Value["TopParent"] as JsonObject)
            .Where(v => v is not null)
            .Cast<JsonObject>()
            .ToList();

        foreach (var top in topParents)
        {
            foreach (var node in Flatten(top))
            {
                resolver.RegisterFromControlNode(node);
            }
        }
    }

    private static void ValidateRequiredKeywordsFromTemplate(
        JsonObject node,
        Dictionary<object, object?> payload,
        TemplateKeywordResolver keywordResolver)
    {
        if (!keywordResolver.TryGetRequiredKeywords(node, out var required) || required.Count == 0)
        {
            return;
        }

        var missing = new List<string>();
        foreach (var keyword in required)
        {
            var has = payload.TryGetValue(keyword, out var raw)
                      && !string.IsNullOrWhiteSpace(raw?.ToString());
            if (!has)
            {
                missing.Add(keyword);
            }
        }

        if (missing.Count == 0)
        {
            return;
        }

        var controlName = node["Name"]?.GetValue<string>()
                          ?? "<unnamed>";
        var templateName = node["Template"]?["Name"]?.GetValue<string>() ?? "<unknown-template>";
        throw new InvalidDataException(
            $"Control '{controlName}' (template '{templateName}') is missing required YAML keyword(s): {string.Join(", ", missing.OrderBy(x => x, StringComparer.OrdinalIgnoreCase))}.");
    }

    private static void PopulateTemplatePropertyResolverFromEntries(Dictionary<string, byte[]> entries, TemplatePropertyResolver resolver)
    {
        var allTopParentFiles = ParseTopParentFiles(entries, "Controls/")
            .Concat(ParseTopParentFiles(entries, "Components/"))
            .Select(kv => kv.Value["TopParent"] as JsonObject)
            .Where(v => v is not null)
            .Cast<JsonObject>()
            .ToList();

        foreach (var top in allTopParentFiles)
        {
            foreach (var node in Flatten(top))
            {
                resolver.RegisterFromControlNode(node);
            }
        }

        if (entries.TryGetValue("References/Templates.json", out var templatesBytes))
        {
            var templatesRoot = JsonNode.Parse(templatesBytes)?.AsObject();
            var usedTemplates = templatesRoot?["UsedTemplates"] as JsonArray;
            if (usedTemplates is not null)
            {
                foreach (var t in usedTemplates.OfType<JsonObject>())
                {
                    var name = t["Name"]?.GetValue<string>() ?? string.Empty;
                    var id = t["Id"]?.GetValue<string>() ?? string.Empty;
                    var xml = t["Template"]?.GetValue<string>() ?? string.Empty;

                    if (string.IsNullOrWhiteSpace(id))
                    {
                        id = ParseTemplateId(xml);
                    }

                    if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(id))
                    {
                        continue;
                    }

                    resolver.RegisterTemplateProperties(name, id, ParseTemplatePropertyNames(xml));
                }
            }
        }
    }

    private static void ValidatePropertiesAgainstTemplate(JsonObject node, Dictionary<object, object?> props, TemplatePropertyResolver resolver)
    {
        var controlName = node["Name"]?.GetValue<string>() ?? "<unnamed>";
        var parentName = node["Parent"]?.GetValue<string>() ?? string.Empty;
        var controlPath = string.IsNullOrWhiteSpace(parentName) ? controlName : $"{parentName}/{controlName}";
        var templateNameForNode = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;

        if (string.Equals(templateNameForNode, "screen", StringComparison.OrdinalIgnoreCase))
        {
            // Screen properties in source schema can include behavior members (for example OnVisible)
            // that are not always present in extracted template metadata.
            return;
        }

        if (!resolver.TryGetAllowedProperties(node, out var allowedProperties) || allowedProperties.Count == 0)
        {
            var templateNameMissing = node["Template"]?["Name"]?.GetValue<string>() ?? "<unknown-template>";
            var templateVersionMissing = node["Template"]?["Version"]?.GetValue<string>() ?? "<unknown-version>";

            throw new InvalidDataException(
                $"Cannot validate properties for control '{controlPath}' because template metadata is unavailable for '{templateNameMissing}@{templateVersionMissing}'. "
                + "Property validation is strict; ensure References/Templates.json contains this template definition.");
        }

        foreach (var ruleProp in ((node["Rules"] as JsonArray) ?? new JsonArray())
                     .OfType<JsonObject>()
                     .Select(r => r["Property"]?.GetValue<string>() ?? string.Empty)
                     .Where(p => !string.IsNullOrWhiteSpace(p)))
        {
            allowedProperties.Add(ruleProp);
        }

        foreach (var stateProp in ((node["ControlPropertyState"] as JsonArray) ?? new JsonArray())
                     .OfType<JsonObject>()
                     .Select(s => s["Property"]?.GetValue<string>() ?? string.Empty)
                     .Where(p => !string.IsNullOrWhiteSpace(p)))
        {
            allowedProperties.Add(stateProp);
        }

        if (IsModernTextInputTemplate(node))
        {
            allowedProperties.Add("Value");
            allowedProperties.Add("Placeholder");
            allowedProperties.Add("Default");
            allowedProperties.Add("HintText");
        }

        ValidateSourcePropertyCompatibility(node, props);

        var unknown = new List<string>();
        foreach (var (k, _) in props)
        {
            var rawPropertyName = k?.ToString() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(rawPropertyName))
            {
                continue;
            }

            var propertyName = NormalizeSourcePropertyName(node, rawPropertyName);
            if (!allowedProperties.Contains(propertyName))
            {
                unknown.Add(rawPropertyName);
            }
        }

        if (unknown.Count > 0)
        {
            var templateName = node["Template"]?["Name"]?.GetValue<string>() ?? "<unknown-template>";
            var templateVersion = node["Template"]?["Version"]?.GetValue<string>() ?? "<unknown-version>";

            var orderedAllowed = allowedProperties.OrderBy(x => x, StringComparer.OrdinalIgnoreCase).ToList();
            var suggestions = unknown
                .OrderBy(x => x, StringComparer.OrdinalIgnoreCase)
                .Select(u =>
                {
                    var nearest = GetNearestPropertyNames(u, orderedAllowed, maxSuggestions: 3);
                    return nearest.Count == 0
                        ? $"- {u}"
                        : $"- {u} (did you mean: {string.Join(", ", nearest)})";
                })
                .ToList();

            throw new InvalidDataException(
                $"Unknown properties for control '{controlPath}' (template '{templateName}@{templateVersion}')."
                + Environment.NewLine
                + string.Join(Environment.NewLine, suggestions)
                + Environment.NewLine
                + $"Allowed properties ({orderedAllowed.Count}): {string.Join(", ", orderedAllowed)}"
                + Environment.NewLine
                + "Tip: verify with 'template-properties <template-name> [template-version]'.");
        }
    }

    private static void ValidateSourceControlCompatibility(string controlType)
    {
        var raw = controlType?.Trim() ?? string.Empty;
        if (string.IsNullOrWhiteSpace(raw))
        {
            return;
        }

        var typePart = raw.Split('@', 2, StringSplitOptions.TrimEntries)[0];
        var normalizedType = typePart.Trim().ToLowerInvariant();
        var requestedVersion = raw.Split('@', 2, StringSplitOptions.TrimEntries) is var parts && parts.Length == 2 ? parts[1] : string.Empty;

        // Source Code schema expects modern text-input control versions (0.0.x).
        // Classic Text@2.x style compiles through legacy template metadata but fails in Studio validation.
        if (string.Equals(normalizedType, "text", StringComparison.OrdinalIgnoreCase)
            && !string.IsNullOrWhiteSpace(requestedVersion)
            && !requestedVersion.StartsWith("0.0.", StringComparison.OrdinalIgnoreCase))
        {
            throw new InvalidDataException(
                $"Control '{controlType}' is incompatible with Source Code (*.pa.yaml) schema. "
                + "Use modern text input control syntax (for example TextInput@0.0.51+) instead of Text@2.x.");
        }
    }

    private static void ValidateSourcePropertyCompatibility(JsonObject node, Dictionary<object, object?> props)
    {
        var templateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
        var templateVersion = node["Template"]?["Version"]?.GetValue<string>() ?? string.Empty;

        if (string.Equals(templateName, "gallery", StringComparison.OrdinalIgnoreCase))
        {
            var variantName = node["VariantName"]?.GetValue<string>() ?? string.Empty;
            if (!variantName.StartsWith("BrowseLayout_", StringComparison.OrdinalIgnoreCase))
            {
                var studioRejected = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { "Layout", "TemplateWidth" };
                var rejected = props.Keys
                    .Select(k => k?.ToString() ?? string.Empty)
                    .Where(p => studioRejected.Contains(p))
                    .OrderBy(p => p)
                    .ToList();
                if (rejected.Count > 0)
                {
                    var controlName = node["Name"]?.GetValue<string>() ?? "<unnamed>";
                    throw new InvalidDataException(
                        $"Properties {string.Join(", ", rejected.Select(p => $"'{p}'"))} on '{controlName}' (gallery variant '{(string.IsNullOrWhiteSpace(variantName) ? "none" : variantName)}') are rejected by Power Apps Studio (PA2108). " +
                        "Gallery direction is set via the Variant keyword alone (Vertical/Horizontal/VariableHeight). " +
                        "Remove these properties and replace 'Parent.TemplateWidth' in child formulas with 'Parent.Width'.");
                }
            }
        }

        if (!string.Equals(templateName, "text", StringComparison.OrdinalIgnoreCase)
            || string.IsNullOrWhiteSpace(templateVersion)
            || !templateVersion.StartsWith("0.0.", StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        var disallowed = new List<string>();
        if (props.Keys.Any(k => string.Equals(k?.ToString(), "Default", StringComparison.OrdinalIgnoreCase)))
        {
            disallowed.Add("Default");
        }

        if (props.Keys.Any(k => string.Equals(k?.ToString(), "HintText", StringComparison.OrdinalIgnoreCase)))
        {
            disallowed.Add("HintText");
        }

        if (disallowed.Count > 0)
        {
            var controlName = node["Name"]?.GetValue<string>() ?? "<unnamed>";
            throw new InvalidDataException(
                $"Unknown properties for control '{controlName}' (template 'text@{templateVersion}'): {string.Join(", ", disallowed)}. "
                + "Use Source Code schema properties for modern text input controls.");
        }
    }

    private static string NormalizeSourcePropertyName(JsonObject node, string propertyName)
    {
        var normalized = propertyName?.Trim() ?? string.Empty;
        if (string.IsNullOrWhiteSpace(normalized))
        {
            return string.Empty;
        }

        if (!IsModernTextInputTemplate(node))
        {
            return normalized;
        }

        if (string.Equals(normalized, "Default", StringComparison.OrdinalIgnoreCase))
        {
            return "Value";
        }

        if (string.Equals(normalized, "HintText", StringComparison.OrdinalIgnoreCase))
        {
            return "Placeholder";
        }

        return normalized;
    }

    private static bool IsModernTextInputTemplate(JsonObject node)
    {
        var templateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
        var templateId = node["Template"]?["Id"]?.GetValue<string>() ?? string.Empty;
        return string.Equals(templateName, "PowerApps_CoreControls_TextInputCanvas", StringComparison.OrdinalIgnoreCase)
               || templateId.Contains("PowerApps_CoreControls_TextInputCanvas", StringComparison.OrdinalIgnoreCase);
    }

    private static List<string> GetNearestPropertyNames(string input, IReadOnlyList<string> candidates, int maxSuggestions)
    {
        if (string.IsNullOrWhiteSpace(input) || candidates.Count == 0 || maxSuggestions <= 0)
        {
            return [];
        }

        var normalizedInput = input.Trim();
        var scored = new List<(string Name, int Distance)>();
        foreach (var candidate in candidates)
        {
            if (string.IsNullOrWhiteSpace(candidate))
            {
                continue;
            }

            var distance = LevenshteinDistance(normalizedInput, candidate);
            scored.Add((candidate, distance));
        }

        var threshold = Math.Max(2, normalizedInput.Length / 3);
        return scored
            .OrderBy(s => s.Distance)
            .ThenBy(s => s.Name, StringComparer.OrdinalIgnoreCase)
            .Where(s => s.Distance <= threshold)
            .Take(maxSuggestions)
            .Select(s => s.Name)
            .ToList();
    }

    private static int LevenshteinDistance(string a, string b)
    {
        if (string.Equals(a, b, StringComparison.OrdinalIgnoreCase))
        {
            return 0;
        }

        if (a.Length == 0)
        {
            return b.Length;
        }

        if (b.Length == 0)
        {
            return a.Length;
        }

        var aa = a.ToLowerInvariant();
        var bb = b.ToLowerInvariant();
        var prev = new int[bb.Length + 1];
        var curr = new int[bb.Length + 1];

        for (var j = 0; j <= bb.Length; j++)
        {
            prev[j] = j;
        }

        for (var i = 1; i <= aa.Length; i++)
        {
            curr[0] = i;
            for (var j = 1; j <= bb.Length; j++)
            {
                var cost = aa[i - 1] == bb[j - 1] ? 0 : 1;
                curr[j] = Math.Min(
                    Math.Min(curr[j - 1] + 1, prev[j] + 1),
                    prev[j - 1] + cost);
            }

            (prev, curr) = (curr, prev);
        }

        return prev[bb.Length];
    }

    private static void PopulateMetadataResolverFromEntries(Dictionary<string, byte[]> entries, ControlMetadataResolver resolver)
    {
        var allTopParentFiles = ParseTopParentFiles(entries, "Controls/")
            .Concat(ParseTopParentFiles(entries, "Components/"))
            .Select(kv => kv.Value["TopParent"] as JsonObject)
            .Where(v => v is not null)
            .Cast<JsonObject>()
            .ToList();

        foreach (var top in allTopParentFiles)
        {
            foreach (var node in Flatten(top))
            {
                resolver.RegisterFromControlNode(node);
            }
        }

        if (entries.TryGetValue("References/Templates.json", out var templatesBytes)
            && JsonNode.Parse(templatesBytes) is JsonObject templatesRoot
            && templatesRoot["UsedTemplates"] is JsonArray usedTemplates)
        {
            foreach (var t in usedTemplates.OfType<JsonObject>())
            {
                var name = t["Name"]?.GetValue<string>() ?? string.Empty;
                var id = t["Id"]?.GetValue<string>() ?? string.Empty;
                var templateXml = t["Template"]?.GetValue<string>() ?? string.Empty;
                if (string.IsNullOrWhiteSpace(id))
                {
                    id = ParseTemplateId(templateXml);
                }

                resolver.RegisterTemplatePropertyDatatypesFromXml(name, id, templateXml);
            }
        }
    }

    private static void PopulateTemplateResolverFromEntries(Dictionary<string, byte[]> entries, TemplateResolver resolver)
    {
        var allTopParentFiles = ParseTopParentFiles(entries, "Controls/")
            .Concat(ParseTopParentFiles(entries, "Components/"))
            .Select(kv => kv.Value["TopParent"] as JsonObject)
            .Where(v => v is not null)
            .Cast<JsonObject>()
            .ToList();

        var indexByName = new Dictionary<string, JsonObject>(StringComparer.OrdinalIgnoreCase);
        foreach (var top in allTopParentFiles)
        {
            IndexByName(top, indexByName);

            foreach (var node in Flatten(top))
            {
                resolver.RegisterTemplateFromControlNode(node);
            }
        }

        if (entries.TryGetValue("References/Templates.json", out var templatesBytes))
        {
            var templatesRoot = JsonNode.Parse(templatesBytes)?.AsObject();
            var usedTemplates = templatesRoot?["UsedTemplates"] as JsonArray;
            if (usedTemplates is not null)
            {
                foreach (var t in usedTemplates.OfType<JsonObject>())
                {
                    var name = t["Name"]?.GetValue<string>() ?? string.Empty;
                    var id = t["Id"]?.GetValue<string>() ?? string.Empty;
                    var version = t["Version"]?.GetValue<string>() ?? string.Empty;
                    resolver.RegisterTemplate(name, id, version);
                }
            }
        }

        var deserializer = new DeserializerBuilder().IgnoreUnmatchedProperties().Build();
        foreach (var (path, bytes) in entries
                     .Where(e => e.Key.StartsWith("Src/", StringComparison.OrdinalIgnoreCase)
                                 && e.Key.EndsWith(".pa.yaml", StringComparison.OrdinalIgnoreCase)))
        {
            var fileName = Path.GetFileName(path);
            if (string.Equals(fileName, "App.pa.yaml", StringComparison.OrdinalIgnoreCase)
                || string.Equals(fileName, "_EditorState.pa.yaml", StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            var yaml = Encoding.UTF8.GetString(bytes);
            if (!TryParseYamlMap(deserializer, yaml, out var root))
            {
                continue;
            }

            if (TryGetMap(root, "Screens", out var screens))
            {
                foreach (var kv in screens)
                {
                    var rootName = kv.Key?.ToString() ?? string.Empty;
                    if (string.IsNullOrWhiteSpace(rootName) || kv.Value is not Dictionary<object, object?> payload)
                    {
                        continue;
                    }

                    RegisterControlMappingsFromYamlPayload(payload, rootName, indexByName, resolver);
                }
            }

            if (TryGetMap(root, "ComponentDefinitions", out var components))
            {
                foreach (var kv in components)
                {
                    var rootName = kv.Key?.ToString() ?? string.Empty;
                    if (string.IsNullOrWhiteSpace(rootName) || kv.Value is not Dictionary<object, object?> payload)
                    {
                        continue;
                    }

                    RegisterControlMappingsFromYamlPayload(payload, rootName, indexByName, resolver);
                }
            }
        }
    }

    private static void RegisterControlMappingsFromYamlPayload(
        Dictionary<object, object?> payload,
        string controlName,
        IReadOnlyDictionary<string, JsonObject> indexByName,
        TemplateResolver resolver)
    {
        if (payload.TryGetValue("Control", out var controlTypeObj)
            && controlTypeObj is not null
            && indexByName.TryGetValue(controlName, out var controlNode))
        {
            resolver.RegisterControlType(controlTypeObj.ToString() ?? string.Empty, controlNode);
        }

        if (!payload.TryGetValue("Children", out var childrenObj) || childrenObj is not List<object?> children)
        {
            return;
        }

        foreach (var child in children)
        {
            if (child is not Dictionary<object, object?> singleton || singleton.Count != 1)
            {
                continue;
            }

            var kv = singleton.First();
            var childName = kv.Key?.ToString() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(childName) || kv.Value is not Dictionary<object, object?> childPayload)
            {
                continue;
            }

            RegisterControlMappingsFromYamlPayload(childPayload, childName, indexByName, resolver);
        }
    }

    private static Dictionary<string, byte[]> ReadEntriesFromMsApp(string msappPath)
    {
        using var stream = File.OpenRead(msappPath);
        return ReadEntriesFromMsAppStream(stream);
    }

    private static Dictionary<string, byte[]> ReadEntriesFromMsAppStream(Stream source)
    {
        var entries = new Dictionary<string, byte[]>(StringComparer.OrdinalIgnoreCase);
        using var archive = new ZipArchive(source, ZipArchiveMode.Read, leaveOpen: false);
        foreach (var entry in archive.Entries)
        {
            using var stream = entry.Open();
            using var memory = new MemoryStream();
            stream.CopyTo(memory);
            entries[entry.FullName.Replace('\\', '/')] = memory.ToArray();
        }

        return entries;
    }

    private static bool ReadEmbeddedAllControlsEntries(out Dictionary<string, byte[]> entries)
    {
        entries = new Dictionary<string, byte[]>(StringComparer.OrdinalIgnoreCase);
        var assembly = typeof(YamlFirstPackaging).Assembly;
        var stream = assembly.GetManifestResourceStream("MsAppToolkit.Resources.AllControls.msapp");
        if (stream is null)
        {
            var fallback = assembly.GetManifestResourceNames()
                .FirstOrDefault(n => n.EndsWith("All controls.msapp", StringComparison.OrdinalIgnoreCase)
                                     || n.EndsWith("AllControls.msapp", StringComparison.OrdinalIgnoreCase));

            if (!string.IsNullOrWhiteSpace(fallback))
            {
                stream = assembly.GetManifestResourceStream(fallback);
            }
        }

        if (stream is null)
        {
           throw new InvalidOperationException("Could not find embedded AllControls.msapp resource. Ensure it is included in the project with the correct name.");
        }

        using (stream)
        {
            entries = ReadEntriesFromMsAppStream(stream);
            return entries.Count > 0;
        }
    }

    private static IReadOnlyList<UsedTemplate> ReadUsedTemplates(IReadOnlyDictionary<string, byte[]> entries)
    {
        if (!entries.TryGetValue("References/Templates.json", out var templatesBytes))
        {
            return [];
        }

        var templatesRoot = JsonNode.Parse(templatesBytes)?.AsObject();
        var usedTemplates = templatesRoot?["UsedTemplates"] as JsonArray;
        if (usedTemplates is null)
        {
            return [];
        }

        var list = new List<UsedTemplate>();
        foreach (var item in usedTemplates.OfType<JsonObject>())
        {
            var name = item["Name"]?.GetValue<string>() ?? string.Empty;
            var id = item["Id"]?.GetValue<string>() ?? string.Empty;
            var version = item["Version"]?.GetValue<string>() ?? string.Empty;
            var templateXml = item["Template"]?.GetValue<string>() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(version))
            {
                continue;
            }

            if (string.IsNullOrWhiteSpace(id))
            {
                id = ParseTemplateId(templateXml);
            }

            if (string.IsNullOrWhiteSpace(id))
            {
                id = $"http://microsoft.com/appmagic/{name}";
            }

            list.Add(new UsedTemplate(name, version, id, templateXml));
        }

        return list;
    }

    private static IReadOnlyList<JsonObject> ReadPcfTemplates(IReadOnlyDictionary<string, byte[]> entries)
    {
        if (!entries.TryGetValue("References/Templates.json", out var templatesBytes))
        {
            return [];
        }

        var templatesRoot = JsonNode.Parse(templatesBytes)?.AsObject();
        var pcfTemplates = templatesRoot?["PcfTemplates"] as JsonArray;
        if (pcfTemplates is null)
        {
            return [];
        }

        return pcfTemplates.OfType<JsonObject>().Select(t => (JsonObject)t.DeepClone()).ToList();
    }

    /// <summary>
    /// Reads all control nodes in the given entries (Controls/*.json + Components/*.json)
    /// and returns a mapping of template-name (lowercased)  distinct VariantName values.
    /// This is the authoritative source for which templates require a Variant keyword and
    /// what the valid variant values are.
    /// </summary>
    private static IReadOnlyDictionary<string, IReadOnlyList<string>> CollectVariantsByTemplateName(Dictionary<string, byte[]> entries)
    {
        var result = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);

        var allTopParents = ParseTopParentFiles(entries, "Controls/")
            .Concat(ParseTopParentFiles(entries, "Components/"))
            .Select(kv => kv.Value["TopParent"] as JsonObject)
            .Where(v => v is not null)
            .Cast<JsonObject>();

        foreach (var top in allTopParents)
        {
            foreach (var node in Flatten(top))
            {
                var tplName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
                var variantName = node["VariantName"]?.GetValue<string>() ?? string.Empty;
                if (string.IsNullOrWhiteSpace(tplName) || string.IsNullOrWhiteSpace(variantName))
                {
                    continue;
                }

                if (!result.TryGetValue(tplName, out var set))
                {
                    set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                    result[tplName] = set;
                }

                set.Add(variantName);
            }
        }

        return result.ToDictionary(
            kv => kv.Key,
            kv => (IReadOnlyList<string>)kv.Value.OrderBy(v => v, StringComparer.OrdinalIgnoreCase).ToList(),
            StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Returns true when packing will require a non-empty Variant keyword for the given template.
    /// This is the case when any existing control node uses this template with a non-empty VariantName.
    /// </summary>
    private static bool RequiresVariantKeyword(
        string templateName,
        string templateId,
        string templateXml,
        IReadOnlyDictionary<string, IReadOnlyList<string>> variantMap)
    {
        // Explicit variant nodes inside the template XML also trigger the requirement.
        if (ParseVariantsFromTemplateXml(templateXml).Count > 0)
        {
            return true;
        }

        if (!string.IsNullOrWhiteSpace(templateName) && variantMap.ContainsKey(templateName))
        {
            return true;
        }

        return false;
    }

    /// <summary>
    /// Returns the union of variants from the template XML and from existing control nodes.
    /// </summary>
    private static IReadOnlyList<string> MergeVariants(
        string templateName,
        string templateId,
        string templateXml,
        IReadOnlyDictionary<string, IReadOnlyList<string>> variantMap)
    {
        var merged = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        foreach (var v in ParseVariantsFromTemplateXml(templateXml))
        {
            merged.Add(v);
        }

        if (!string.IsNullOrWhiteSpace(templateName) && variantMap.TryGetValue(templateName, out var fromNodes))
        {
            foreach (var v in fromNodes)
            {
                merged.Add(v);
            }
        }

        return merged.OrderBy(v => v, StringComparer.OrdinalIgnoreCase).ToList();
    }

    /// <summary>
    /// Parses variant names declared directly in a template's XML via &lt;variant name=""/&gt; elements.
    /// </summary>
    private static IReadOnlyList<string> ParseVariantsFromTemplateXml(string templateXml)
    {
        if (string.IsNullOrWhiteSpace(templateXml))
        {
            return [];
        }

        try
        {
            var root = XDocument.Parse(templateXml).Root;
            if (root is null)
            {
                return [];
            }

            return root
                .Descendants()
                .Where(e => string.Equals(e.Name.LocalName, "variant", StringComparison.OrdinalIgnoreCase))
                .Select(e => e.Attribute("name")?.Value ?? string.Empty)
                .Where(n => !string.IsNullOrWhiteSpace(n))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .OrderBy(n => n, StringComparer.OrdinalIgnoreCase)
                .ToList();
        }
        catch
        {
            return [];
        }
    }

    /// <summary>Parses top-level insertMetadata category names from template XML.</summary>
    private static IReadOnlyList<string> ParseInsertCategoriesFromTemplateXml(string templateXml)
    {
        if (string.IsNullOrWhiteSpace(templateXml)) return [];
        try
        {
            var root = XDocument.Parse(templateXml).Root;
            if (root is null) return [];
            return root
                .Descendants()
                .Where(e => string.Equals(e.Name.LocalName, "insertMetadata", StringComparison.OrdinalIgnoreCase))
                .SelectMany(im => im.Elements()
                    .Where(c => string.Equals(c.Name.LocalName, "category", StringComparison.OrdinalIgnoreCase))
                    .Select(c => c.Attribute("name")?.Value ?? string.Empty))
                .Where(n => !string.IsNullOrWhiteSpace(n))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .OrderBy(n => n, StringComparer.OrdinalIgnoreCase)
                .ToList();
        }
        catch { return []; }
    }

    /// <summary>
    /// Returns preview flag names declared in the template root-level requiredConditions block.
    /// These apply when the template itself is used, regardless of variant.
    /// </summary>
    private static IReadOnlyList<string> ParseRootPreviewFlagsFromTemplateXml(string templateXml)
    {
        if (string.IsNullOrWhiteSpace(templateXml)) return [];
        try
        {
            var root = XDocument.Parse(templateXml).Root;
            if (root is null) return [];
            // Find requiredConditions that are direct children of the root (or the first non-variant child),
            // i.e. NOT nested inside a controlVariant element.
            var variantNames = root.Descendants()
                .Where(e => string.Equals(e.Name.LocalName, "controlVariant", StringComparison.OrdinalIgnoreCase))
                .Select(e => (XElement?)e)
                .ToHashSet();

            return root.Descendants()
                .Where(e => string.Equals(e.Name.LocalName, "previewFlag", StringComparison.OrdinalIgnoreCase))
                .Where(e => !e.Ancestors().Any(a => variantNames.Contains(a)))
                .Select(e => e.Attribute("name")?.Value ?? string.Empty)
                .Where(f => !string.IsNullOrWhiteSpace(f))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .ToList();
        }
        catch { return []; }
    }

    /// <summary>
    /// Returns preview flag names required by each controlVariant in the template XML.
    /// Key = variant name, Value = list of required preview flag names.
    /// </summary>
    private static IReadOnlyDictionary<string, IReadOnlyList<string>> ParseVariantPreviewFlagsFromTemplateXml(string templateXml)
    {
        if (string.IsNullOrWhiteSpace(templateXml))
            return new Dictionary<string, IReadOnlyList<string>>(StringComparer.OrdinalIgnoreCase);
        try
        {
            var root = XDocument.Parse(templateXml).Root;
            if (root is null)
                return new Dictionary<string, IReadOnlyList<string>>(StringComparer.OrdinalIgnoreCase);

            var result = new Dictionary<string, IReadOnlyList<string>>(StringComparer.OrdinalIgnoreCase);
            foreach (var variant in root.Descendants()
                         .Where(e => string.Equals(e.Name.LocalName, "controlVariant", StringComparison.OrdinalIgnoreCase)))
            {
                var vName = variant.Attribute("name")?.Value ?? string.Empty;
                if (string.IsNullOrWhiteSpace(vName)) continue;
                var flags = variant.Descendants()
                    .Where(e => string.Equals(e.Name.LocalName, "previewFlag", StringComparison.OrdinalIgnoreCase))
                    .Select(e => e.Attribute("name")?.Value ?? string.Empty)
                    .Where(f => !string.IsNullOrWhiteSpace(f))
                    .Distinct(StringComparer.OrdinalIgnoreCase)
                    .ToList();
                if (flags.Count > 0)
                    result[vName] = flags;
            }
            return result;
        }
        catch { return new Dictionary<string, IReadOnlyList<string>>(StringComparer.OrdinalIgnoreCase); }
    }

    /// <summary>
    /// Builds the list of AppPreviewFlagsMap requirements derived from a template's
    /// insertMetadata categories and controlVariant previewFlag declarations.
    /// </summary>
    private static IReadOnlyList<TemplateAppFlagRequirement> BuildAppFlagRequirements(string templateXml)
    {
        var reqs = new List<TemplateAppFlagRequirement>();
        if (string.IsNullOrWhiteSpace(templateXml)) return reqs;

        var seen = new HashSet<(string FlagName, bool RequiredValue)>();
        void AddUnique(TemplateAppFlagRequirement req)
        {
            if (seen.Add((req.FlagName, req.RequiredValue)))
                reqs.Add(req);
        }

        var categories = ParseInsertCategoriesFromTemplateXml(templateXml);

        // ClassicControls controls that also appear in the "Display" insert category (e.g. Label)
        // do NOT have a Fluent V9 replacement and work regardless of the classiccontrols flag.
        // Only controls that are ClassicControls but NOT in Display are replaced by Fluent V9 PCF
        // equivalents when classiccontrols=false (e.g. Button, Checkbox, Dropdown, Radio, ...).
        if (categories.Contains("ClassicControls", StringComparer.OrdinalIgnoreCase)
            && !categories.Contains("Display", StringComparer.OrdinalIgnoreCase))
        {
            AddUnique(new TemplateAppFlagRequirement(
                "classiccontrols", true,
                "Classic Control (Input) -- when classiccontrols=false (the default), Studio may replace this control with a " +
                "Fluent V9 PCF equivalent that has different/fewer properties (e.g. button loses Fill, Color, Size, RadiusXxx). " +
                "Set AppPreviewFlagsMap.classiccontrols=true to use the classic property set, or switch to a control that " +
                "has no Fluent V9 replacement (e.g. use Label instead of Button for fully-styled interactive elements)."));
        }

        if (categories.Contains("FluentV9", StringComparer.OrdinalIgnoreCase))
        {
            AddUnique(new TemplateAppFlagRequirement(
                "fluentv9controls", true,
                "Fluent V9 Control -- only available when fluentv9controls=true (default true in modern apps)."));
        }

        // Template-level (root) requiredConditions -- apply regardless of variant.
        var rootFlags = ParseRootPreviewFlagsFromTemplateXml(templateXml);
        foreach (var flagName in rootFlags)
        {
            var appFlagKey = MapPreviewFlagNameToAppFlag(flagName);
            if (appFlagKey is not null)
            {
                AddUnique(new TemplateAppFlagRequirement(
                    appFlagKey, true,
                    $"Template-level required flag '{flagName}' " +
                    $"(AppPreviewFlagsMap.{appFlagKey}=true)."));
            }
        }

        // Variant-level requiredConditions.
        var variantFlags = ParseVariantPreviewFlagsFromTemplateXml(templateXml);
        foreach (var (variantName, flags) in variantFlags.OrderBy(kv => kv.Key, StringComparer.OrdinalIgnoreCase))
        {
            foreach (var flagName in flags)
            {
                var appFlagKey = MapPreviewFlagNameToAppFlag(flagName);
                if (appFlagKey is not null)
                {
                    AddUnique(new TemplateAppFlagRequirement(
                        appFlagKey, true,
                        $"Variant '{variantName}' requires preview flag '{flagName}' " +
                        $"(AppPreviewFlagsMap.{appFlagKey}=true)."));
                }
            }
        }

        return reqs;
    }

    /// <summary>Maps a previewFlag/@name value to the corresponding AppPreviewFlagsMap key.</summary>
    private static string? MapPreviewFlagNameToAppFlag(string previewFlagName) =>
        previewFlagName switch
        {
            "FluentV9ControlsPreview" => "fluentv9controls",
            _ => null
        };

    /// <summary>Reads AppPreviewFlagsMap from the app's Properties.json entries, falling back to defaults when missing.</summary>
    private static IReadOnlyDictionary<string, bool> ReadAppPreviewFlagsMap(Dictionary<string, byte[]> entries)
    {
        // Build defaults first (matches what NormalizePropertiesMetadata applies to new apps).
        var defaults = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
        foreach (var (k, v) in BuildDefaultAppPreviewFlagsMap())
        {
            if (v is JsonValue jv && (jv.GetValueKind() == JsonValueKind.True || jv.GetValueKind() == JsonValueKind.False))
                defaults[k] = jv.GetValue<bool>();
        }

        if (!entries.TryGetValue("Properties.json", out var bytes))
            return defaults;
        try
        {
            var root = JsonNode.Parse(Encoding.UTF8.GetString(bytes))?.AsObject();
            var flagsNode = root?["AppPreviewFlagsMap"]?.AsObject();
            if (flagsNode is null)
                return defaults;

            // Overlay explicit values from Properties.json on top of the defaults.
            var result = new Dictionary<string, bool>(defaults, StringComparer.OrdinalIgnoreCase);
            foreach (var (key, value) in flagsNode)
            {
                if (value is not null && (value.GetValueKind() == JsonValueKind.True || value.GetValueKind() == JsonValueKind.False))
                    result[key] = value.GetValue<bool>();
            }
            return result;
        }
        catch { return defaults; }
    }

    /// <summary>
    /// Builds a map of embedded template name to AppPreviewFlagsMap requirements
    /// derived from the embedded All controls.msapp template XMLs.
    /// </summary>
    private static IReadOnlyDictionary<string, IReadOnlyList<TemplateAppFlagRequirement>> BuildTemplateFlagRequirementsMap()
    {
        ReadEmbeddedAllControlsEntries(out var embeddedEntries);
        var templates = ReadUsedTemplates(embeddedEntries);
        return templates.ToDictionary(
            t => t.Name,
            t => BuildAppFlagRequirements(t.TemplateXml),
            StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Throws <see cref="InvalidDataException"/> when a control's template has AppPreviewFlagsMap
    /// requirements that conflict with the current app's flag settings.
    /// </summary>
    private static void EnforceAppFlagRequirements(
        JsonObject node,
        IReadOnlyDictionary<string, bool> appFlags,
        IReadOnlyDictionary<string, IReadOnlyList<TemplateAppFlagRequirement>> flagRequirementsMap)
    {
        var templateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
        var templateVersion = node["Template"]?["Version"]?.GetValue<string>() ?? string.Empty;
        if (string.IsNullOrWhiteSpace(templateName)) return;
        if (string.Equals(templateName, "screen", StringComparison.OrdinalIgnoreCase)) return;

        if (!flagRequirementsMap.TryGetValue(templateName, out var requirements) || requirements.Count == 0)
            return;

        var controlName = node["Name"]?.GetValue<string>() ?? "<unnamed>";
        foreach (var req in requirements)
        {
            if (appFlags.TryGetValue(req.FlagName, out var actualValue) && actualValue != req.RequiredValue)
            {
                throw new InvalidDataException(
                    $"Control '{controlName}' uses '{templateName}@{templateVersion}': " +
                    $"AppPreviewFlagsMap.{req.FlagName}={req.RequiredValue} required but is {actualValue}. " +
                    req.Reason);
            }
        }
    }

    /// <summary>
    /// Returns human-readable compatibility notes for controls with known restrictions or
    /// behaviours that differ from what the standard property list alone implies.
    /// </summary>
    private static IReadOnlyList<string> GetCompatibilityNotes(string templateName, string templateVersion)
    {
        var notes = new List<string>();

        if (string.Equals(templateName, "text", StringComparison.OrdinalIgnoreCase))
        {
            notes.Add("BLOCKED in YAML: Text@2.x cannot be used directly in .pa.yaml files.");
            notes.Add("Use 'Classic/TextInput@2.3.2' (bypasses the block and resolves to the TextInputCanvas PCF control).");
            notes.Add("Alternatively use 'TextInput@0.0.51+' for the modern PCF text input.");
            notes.Add("When using TextInput@0.0.x: write 'Placeholder' instead of 'HintText', 'Value' instead of 'Default'.");
            notes.Add("When using TextInput@0.0.x: only X, Y, Width, Height, DisplayMode, Placeholder, Value are validated.");
        }
        else if (string.Equals(templateName, "PowerApps_CoreControls_TextInputCanvas", StringComparison.OrdinalIgnoreCase))
        {
            notes.Add("Modern PCF text input resolved via 'TextInput@<version>' or 'Classic/TextInput@2.3.2'.");
            notes.Add("Write 'Placeholder' (not 'HintText') and 'Value' (not 'Default') for this control.");
            notes.Add("Only X, Y, Width, Height, DisplayMode, Placeholder, Value properties pass validation.");
            if (!string.IsNullOrWhiteSpace(templateVersion) && templateVersion.StartsWith("0.0.", StringComparison.OrdinalIgnoreCase))
            {
                notes.Add("Tip: 'Classic/TextInput@2.3.2' skips the strict property-rename check and allows HintText.");
            }
        }
        else if (string.Equals(templateName, "icon", StringComparison.OrdinalIgnoreCase))
        {
            notes.Add("Each icon shape IS the Variant. Use 'Variant: <IconName>' e.g. Variant: ChevronRight");
            notes.Add("Common icon names: Add, ArrowLeft, ArrowRight, Back, Cancel, ChevronDown, ChevronLeft, ChevronRight, ChevronUp, Close, Copy, Delete, Edit, Email, Filter, Home, Info, Mail, Menu, More, Next, Notification, Phone, Pin, Print, Refresh, Save, Search, Settings, Share, Sort, Trash, Undo, Up, Warning.");
        }
        else if (string.Equals(templateName, "gallery", StringComparison.OrdinalIgnoreCase))
        {
            notes.Add("Requires Variant keyword. YAML-facing aliases: Vertical, Horizontal, VariableHeight.");
            notes.Add("Internal VariantName equivalents: galleryVertical, galleryHorizontal, variableTemplateHeightGallery (both forms are accepted).");
            notes.Add("Browse-gallery layouts (BrowseLayout_*) are also valid but expect specific DataSource field bindings.");
        }
        else if (string.Equals(templateName, "form", StringComparison.OrdinalIgnoreCase))
        {
            notes.Add("Requires Variant keyword. Use 'Variant: Classic' for the standard cards form style.");
            notes.Add("Auto-generates data cards for DataSource fields when DataSource and Item are set.");
        }
        else if (string.Equals(templateName, "groupContainer", StringComparison.OrdinalIgnoreCase))
        {
            notes.Add("Requires Variant keyword. YAML-facing aliases: ManualLayout, AutoLayout, GridLayout.");
            notes.Add("Internal VariantName equivalents: manualLayoutContainer, horizontalAutoLayoutContainer / verticalAutoLayoutContainer (set by LayoutDirection), gridLayoutContainer.");
            notes.Add("Use 'Variant: ManualLayout' for free-position children via X/Y. Use 'Variant: AutoLayout' with LayoutDirection for flex-stack.");
            notes.Add("Has RadiusTopLeft/Right/BottomLeft/Right, DropShadow, and Fill -- great for styled card containers.");
        }

        return notes;
    }

    private static IReadOnlyList<EmbeddedTemplateProperty> ParseTemplateProperties(string templateXml)
    {
        if (string.IsNullOrWhiteSpace(templateXml))
        {
            return [];
        }

        try
        {
            var root = XDocument.Parse(templateXml).Root;
            if (root is null)
            {
                return [];
            }

            var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            var props = new List<EmbeddedTemplateProperty>();
            foreach (var prop in root.Descendants().Where(e => e.Name.LocalName is "property" or "includeProperty"))
            {
                var name = prop.Attribute("name")?.Value;
                if (string.IsNullOrWhiteSpace(name) || !seen.Add(name))
                {
                    continue;
                }

                var defaultValue = prop.Attribute("defaultValue")?.Value ?? string.Empty;
                var datatype = prop.Attribute("datatype")?.Value ?? string.Empty;
                defaultValue = NormalizeReservedEnumTokenForDatatype(defaultValue, datatype);
                props.Add(new EmbeddedTemplateProperty(name, defaultValue));
            }

            return props;
        }
        catch
        {
            return [];
        }
    }

    private static HashSet<string> ParseTemplatePropertyNames(string templateXml)
    {
        var names = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        if (string.IsNullOrWhiteSpace(templateXml))
        {
            return names;
        }

        try
        {
            var root = XDocument.Parse(templateXml).Root;
            if (root is null)
            {
                return names;
            }

            foreach (var prop in root.Descendants().Where(e => e.Name.LocalName is "property" or "includeProperty" or "overrideProperty"))
            {
                var name = prop.Attribute("name")?.Value;
                if (!string.IsNullOrWhiteSpace(name))
                {
                    names.Add(name);
                }
            }
        }
        catch
        {
            // Ignore malformed template xml.
        }

        return names;
    }

    private static HashSet<string> ParseRequiredYamlKeywords(string templateXml)
    {
        var keywords = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        if (string.IsNullOrWhiteSpace(templateXml))
        {
            return keywords;
        }

        try
        {
            var root = XDocument.Parse(templateXml).Root;
            if (root is null)
            {
                return keywords;
            }

            // Many templates expose variant definitions via <variant .../> entries.
            // When present, YAML source schema requires a non-empty 'Variant' keyword.
            var hasVariantNodes = root
                .Descendants()
                .Any(e => string.Equals(e.Name.LocalName, "variant", StringComparison.OrdinalIgnoreCase));
            if (hasVariantNodes)
            {
                keywords.Add("Variant");
            }
        }
        catch
        {
            // Ignore malformed template xml.
        }

        return keywords;
    }

    private static string ParseTemplateId(string templateXml)
    {
        if (string.IsNullOrWhiteSpace(templateXml))
        {
            return string.Empty;
        }

        try
        {
            var root = XDocument.Parse(templateXml).Root;
            if (root is null)
            {
                return string.Empty;
            }

            return root.Attribute("id")?.Value
                   ?? root.Attribute(XName.Get("id", "http://openajax.org/metadata"))?.Value
                   ?? string.Empty;
        }
        catch
        {
            return string.Empty;
        }
    }

    private static string NormalizeReservedEnumTokenForDatatype(string value, string datatype)
    {
        if (string.IsNullOrWhiteSpace(value) || string.IsNullOrWhiteSpace(datatype))
        {
            return value;
        }

        var trimmed = value.Trim();
        var m = Regex.Match(trimmed, "^%([A-Za-z_][A-Za-z0-9_]*)\\.RESERVED%\\.(.+)$", RegexOptions.CultureInvariant);
        if (!m.Success)
        {
            return value;
        }

        var enumType = m.Groups[1].Value;
        var enumMember = m.Groups[2].Value.Trim();
        if (string.IsNullOrWhiteSpace(enumMember))
        {
            return value;
        }

        if (!string.Equals(enumType, datatype, StringComparison.OrdinalIgnoreCase))
        {
            return value;
        }

        return $"{enumType}.{enumMember}";
    }

    private static string NormalizeReservedEnumToken(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return value;
        }

        var trimmed = value.Trim();
        var m = Regex.Match(trimmed, "^%([A-Za-z_][A-Za-z0-9_]*)\\.RESERVED%\\.(.+)$", RegexOptions.CultureInvariant);
        if (!m.Success)
        {
            return value;
        }

        var enumType = m.Groups[1].Value;
        var enumMember = m.Groups[2].Value.Trim();
        if (string.IsNullOrWhiteSpace(enumMember))
        {
            return value;
        }

        return $"{enumType}.{enumMember}";
    }

    private static (int major, int minor, int patch) SemverTuple(string version)
    {
        var tokens = version.Split('.', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
        var nums = new[] { 0, 0, 0 };
        for (var i = 0; i < Math.Min(3, tokens.Length); i++)
        {
            var digits = new string(tokens[i].TakeWhile(char.IsDigit).ToArray());
            nums[i] = int.TryParse(digits, NumberStyles.Integer, CultureInfo.InvariantCulture, out var parsed) ? parsed : 0;
        }

        return (nums[0], nums[1], nums[2]);
    }

    private static string ToYamlControlName(string templateName)
    {
        if (string.IsNullOrWhiteSpace(templateName))
        {
            return templateName;
        }

        return char.ToUpperInvariant(templateName[0]) + templateName[1..];
    }

    private static void ValidateDataSourcesContainCollections(
        Dictionary<string, byte[]> entries,
        IReadOnlyDictionary<string, JsonObject> topControlFiles,
        IReadOnlyDictionary<string, JsonObject> topComponentFiles)
    {
        var requiredDataSourceNames = ExtractRequiredDataSourceNamesFromRules(topControlFiles, topComponentFiles);

        var dataSourceNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        if (entries.TryGetValue("References/DataSources.json", out var bytes)
            && JsonNode.Parse(bytes) is JsonObject parsed
            && parsed["DataSources"] is JsonArray parsedArray)
        {
            foreach (var ds in parsedArray.OfType<JsonObject>())
            {
                var name = ds["Name"]?.GetValue<string>() ?? string.Empty;
                if (!string.IsNullOrWhiteSpace(name))
                {
                    dataSourceNames.Add(name);
                }
            }
        }

        var missing = requiredDataSourceNames
            .Where(n => !dataSourceNames.Contains(n))
            .OrderBy(n => n, StringComparer.OrdinalIgnoreCase)
            .ToList();

        if (missing.Count > 0)
        {
            throw new InvalidDataException(
                "Missing data sources in References/DataSources.json for: "
                + string.Join(", ", missing)
                + ". Add these data sources explicitly before packing."
                + " Checked formula calls include Collect, ClearCollect, Patch, Remove, RemoveIf, Update, UpdateIf, Defaults, Refresh.");
        }
    }

    private static void RemoveStaticCollectionDataSources(
        Dictionary<string, byte[]> entries,
        IReadOnlyDictionary<string, JsonObject> topControlFiles,
        IReadOnlyDictionary<string, JsonObject> topComponentFiles)
    {
        if (!entries.TryGetValue("References/DataSources.json", out var bytes)
            || JsonNode.Parse(bytes) is not JsonObject root
            || root["DataSources"] is not JsonArray dataSources)
        {
            return;
        }

        var collectionTargets = ExtractCollectionTargetsFromCollectCalls(topControlFiles, topComponentFiles);
        if (collectionTargets.Count == 0)
        {
            return;
        }

        var changed = false;
        for (var i = dataSources.Count - 1; i >= 0; i--)
        {
            if (dataSources[i] is not JsonObject ds)
            {
                continue;
            }

            var name = ds["Name"]?.GetValue<string>() ?? string.Empty;
            var type = ds["Type"]?.GetValue<string>() ?? string.Empty;
            if (!collectionTargets.Contains(name)
                || !string.Equals(type, "StaticDataSourceInfo", StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            dataSources.RemoveAt(i);
            changed = true;
        }

        if (!changed)
        {
            return;
        }

        root["DataSources"] = dataSources;
        entries["References/DataSources.json"] = Encoding.UTF8.GetBytes(root.ToJsonString(JsonOptions));
    }

    private static HashSet<string> ExtractCollectionTargetsFromCollectCalls(
        IReadOnlyDictionary<string, JsonObject> topControlFiles,
        IReadOnlyDictionary<string, JsonObject> topComponentFiles)
    {
        var names = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        IEnumerable<JsonObject> EnumerateTopParents(IReadOnlyDictionary<string, JsonObject> files)
        {
            foreach (var v in files.Values)
            {
                if (v["TopParent"] is JsonObject top)
                {
                    yield return top;
                }
            }
        }

        foreach (var top in EnumerateTopParents(topControlFiles).Concat(EnumerateTopParents(topComponentFiles)))
        {
            foreach (var node in Flatten(top))
            {
                var rules = (node["Rules"] as JsonArray) ?? new JsonArray();
                foreach (var rule in rules.OfType<JsonObject>())
                {
                    var script = rule["InvariantScript"]?.GetValue<string>() ?? string.Empty;
                    if (string.IsNullOrWhiteSpace(script))
                    {
                        continue;
                    }

                    foreach (var call in EnumerateFunctionCalls(script, CollectionSeedFunctions))
                    {
                        if (call.Arguments.Count == 0)
                        {
                            continue;
                        }

                        var name = ParseCollectionName(call.Arguments[0]);
                        if (!string.IsNullOrWhiteSpace(name))
                        {
                            names.Add(name);
                        }
                    }
                }
            }
        }

        return names;
    }

    private static void EnsureCollectionDataSourcesFromRules(
        Dictionary<string, byte[]> entries,
        IReadOnlyDictionary<string, JsonObject> topControlFiles,
        IReadOnlyDictionary<string, JsonObject> topComponentFiles)
    {
        var seedRowsByCollection = ExtractStaticCollectionSeedRows(topControlFiles, topComponentFiles);
        if (seedRowsByCollection.Count == 0)
        {
            return;
        }

        JsonObject root;
        JsonArray dataSources;
        if (entries.TryGetValue("References/DataSources.json", out var existingBytes)
            && JsonNode.Parse(existingBytes) is JsonObject existingRoot
            && existingRoot["DataSources"] is JsonArray existingArray)
        {
            root = existingRoot;
            dataSources = existingArray;
        }
        else
        {
            root = new JsonObject();
            dataSources = new JsonArray();
            root["DataSources"] = dataSources;
        }

        var changed = false;
        foreach (var (collectionName, rows) in seedRowsByCollection)
        {
            if (rows.Count == 0)
            {
                continue;
            }

            var existing = dataSources
                .OfType<JsonObject>()
                .FirstOrDefault(ds => string.Equals(ds["Name"]?.GetValue<string>() ?? string.Empty, collectionName, StringComparison.OrdinalIgnoreCase));

            var newEntry = BuildStaticCollectionDataSourceEntry(collectionName, rows);
            if (existing is null)
            {
                dataSources.Add(newEntry);
                changed = true;
                continue;
            }

            var type = existing["Type"]?.GetValue<string>() ?? string.Empty;
            if (!string.Equals(type, "StaticDataSourceInfo", StringComparison.OrdinalIgnoreCase)
                && !string.IsNullOrWhiteSpace(type))
            {
                continue;
            }

            var existingCount = GetDataSourceRowCount(existing);
            if (existingCount >= rows.Count)
            {
                continue;
            }

            if (existing["IsSampleData"] is not null)
            {
                newEntry["IsSampleData"] = existing["IsSampleData"]!.DeepClone();
            }

            if (existing["IsWritable"] is not null)
            {
                newEntry["IsWritable"] = existing["IsWritable"]!.DeepClone();
            }

            if (existing["OriginalName"] is not null)
            {
                newEntry["OriginalName"] = existing["OriginalName"]!.DeepClone();
            }

            for (var i = 0; i < dataSources.Count; i++)
            {
                if (ReferenceEquals(dataSources[i], existing))
                {
                    dataSources[i] = newEntry;
                    changed = true;
                    break;
                }
            }
        }

        if (!changed)
        {
            return;
        }

        root["DataSources"] = dataSources;
        entries["References/DataSources.json"] = Encoding.UTF8.GetBytes(root.ToJsonString(JsonOptions));
    }

    private static Dictionary<string, List<JsonObject>> ExtractStaticCollectionSeedRows(
        IReadOnlyDictionary<string, JsonObject> topControlFiles,
        IReadOnlyDictionary<string, JsonObject> topComponentFiles)
    {
        var rowsByCollection = new Dictionary<string, List<JsonObject>>(StringComparer.OrdinalIgnoreCase);

        IEnumerable<JsonObject> EnumerateTopParents(IReadOnlyDictionary<string, JsonObject> files)
        {
            foreach (var v in files.Values)
            {
                if (v["TopParent"] is JsonObject top)
                {
                    yield return top;
                }
            }
        }

        foreach (var top in EnumerateTopParents(topControlFiles).Concat(EnumerateTopParents(topComponentFiles)))
        {
            foreach (var node in Flatten(top))
            {
                var rules = (node["Rules"] as JsonArray) ?? new JsonArray();
                foreach (var rule in rules.OfType<JsonObject>())
                {
                    var script = rule["InvariantScript"]?.GetValue<string>() ?? string.Empty;
                    if (string.IsNullOrWhiteSpace(script))
                    {
                        continue;
                    }

                    foreach (var call in EnumerateFunctionCalls(script, CollectionSeedFunctions))
                    {
                        if (call.Arguments.Count <= 1)
                        {
                            continue;
                        }

                        var collectionName = ParseCollectionName(call.Arguments[0]);
                        if (string.IsNullOrWhiteSpace(collectionName))
                        {
                            continue;
                        }

                        var parsedRows = new List<JsonObject>();
                        foreach (var arg in call.Arguments.Skip(1))
                        {
                            if (TryParseStaticRecordLiteral(arg, out var row))
                            {
                                parsedRows.Add(row);
                            }
                        }

                        if (parsedRows.Count == 0)
                        {
                            continue;
                        }

                        if (!rowsByCollection.TryGetValue(collectionName, out var existingRows)
                            || parsedRows.Count > existingRows.Count)
                        {
                            rowsByCollection[collectionName] = parsedRows;
                        }
                    }
                }
            }
        }

        return rowsByCollection;
    }

    private static bool TryParseStaticRecordLiteral(string expression, out JsonObject record)
    {
        record = new JsonObject();
        var trimmed = expression?.Trim() ?? string.Empty;
        if (!trimmed.StartsWith('{') || !trimmed.EndsWith('}'))
        {
            return false;
        }

        var jsonish = RecordKeyRegex.Replace(trimmed, "$1\"$2\":");
        jsonish = TrueFalseRegex.Replace(jsonish, m =>
            string.Equals(m.Value, "true", StringComparison.OrdinalIgnoreCase) ? "true" : "false");

        try
        {
            if (JsonNode.Parse(jsonish) is not JsonObject parsed)
            {
                return false;
            }

            record = parsed;
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static JsonObject BuildStaticCollectionDataSourceEntry(string collectionName, IReadOnlyList<JsonObject> rows)
    {
        var sampleArray = new JsonArray(rows.Select(r => (JsonNode)r.DeepClone()).ToArray());
        var columns = InferColumns(sampleArray);
        var schema = BuildSchema(columns);
        var isSample = collectionName.EndsWith("Sample", StringComparison.OrdinalIgnoreCase);

        return new JsonObject
        {
            ["Name"] = collectionName,
            ["Schema"] = schema,
            ["IsSampleData"] = isSample,
            ["IsWritable"] = true,
            ["Type"] = "StaticDataSourceInfo",
            ["OriginalSchema"] = schema,
            ["Data"] = sampleArray.ToJsonString(),
            ["OriginalName"] = collectionName,
            ["OrderedColumnNames"] = new JsonArray(columns.Select(c => JsonValue.Create(c.Name)).ToArray()),
        };
    }

    private static int GetDataSourceRowCount(JsonObject dataSource)
    {
        var dataText = dataSource["Data"]?.GetValue<string>() ?? string.Empty;
        if (string.IsNullOrWhiteSpace(dataText))
        {
            return 0;
        }

        try
        {
            var parsed = JsonNode.Parse(dataText);
            return parsed switch
            {
                JsonArray arr => arr.Count,
                JsonObject => 1,
                _ => 0,
            };
        }
        catch
        {
            return 0;
        }
    }

    private static Dictionary<string, int> ExtractStaticCollectionSeedMinimums(
        IReadOnlyDictionary<string, JsonObject> topControlFiles,
        IReadOnlyDictionary<string, JsonObject> topComponentFiles)
    {
        var required = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);

        IEnumerable<JsonObject> EnumerateTopParents(IReadOnlyDictionary<string, JsonObject> files)
        {
            foreach (var v in files.Values)
            {
                if (v["TopParent"] is JsonObject top)
                {
                    yield return top;
                }
            }
        }

        foreach (var top in EnumerateTopParents(topControlFiles).Concat(EnumerateTopParents(topComponentFiles)))
        {
            foreach (var node in Flatten(top))
            {
                var rules = (node["Rules"] as JsonArray) ?? new JsonArray();
                foreach (var rule in rules.OfType<JsonObject>())
                {
                    var script = rule["InvariantScript"]?.GetValue<string>() ?? string.Empty;
                    if (string.IsNullOrWhiteSpace(script))
                    {
                        continue;
                    }

                    foreach (var call in EnumerateFunctionCalls(script, CollectionSeedFunctions))
                    {
                        var collectionName = call.Arguments.Count > 0
                            ? ParseCollectionName(call.Arguments[0])
                            : string.Empty;
                        if (string.IsNullOrWhiteSpace(collectionName))
                        {
                            continue;
                        }

                        var staticSeedCount = call.Arguments
                            .Skip(1)
                            .Count(IsStaticRecordLiteral);

                        if (staticSeedCount <= 0)
                        {
                            continue;
                        }

                        if (!required.TryGetValue(collectionName, out var current) || staticSeedCount > current)
                        {
                            required[collectionName] = staticSeedCount;
                        }
                    }
                }
            }
        }

        return required;
    }

    private static bool IsStaticRecordLiteral(string expression)
    {
        var trimmed = expression?.Trim() ?? string.Empty;
        if (!trimmed.StartsWith('{') || !trimmed.EndsWith('}'))
        {
            return false;
        }

        var jsonish = RecordKeyRegex.Replace(trimmed, "$1\"$2\":");
        jsonish = TrueFalseRegex.Replace(jsonish, m =>
            string.Equals(m.Value, "true", StringComparison.OrdinalIgnoreCase) ? "true" : "false");

        try
        {
            return JsonNode.Parse(jsonish) is JsonObject;
        }
        catch
        {
            return false;
        }
    }

    private static IEnumerable<FunctionCall> EnumerateFunctionCalls(string script, IReadOnlyCollection<string> functionNames)
    {
        if (string.IsNullOrWhiteSpace(script))
        {
            yield break;
        }

        var index = 0;
        while (index < script.Length)
        {
            var nextIndex = -1;
            var functionName = string.Empty;
            foreach (var candidate in functionNames)
            {
                var candidateIndex = IndexOfFunction(script, candidate, index);
                if (candidateIndex < 0)
                {
                    continue;
                }

                if (nextIndex < 0 || candidateIndex < nextIndex)
                {
                    nextIndex = candidateIndex;
                    functionName = candidate;
                }
            }

            if (nextIndex < 0)
            {
                yield break;
            }

            var openParen = nextIndex + functionName.Length;
            while (openParen < script.Length && char.IsWhiteSpace(script[openParen]))
            {
                openParen++;
            }

            if (openParen >= script.Length || script[openParen] != '(')
            {
                index = nextIndex + 1;
                continue;
            }

            var closeParen = FindMatchingParen(script, openParen);
            if (closeParen < 0)
            {
                yield break;
            }

            var args = SplitTopLevelArguments(script[(openParen + 1)..closeParen]);
            yield return new FunctionCall(functionName, args);

            index = closeParen + 1;
        }
    }

    private static int IndexOfFunction(string text, string functionName, int startIndex)
    {
        var i = startIndex;
        while (i < text.Length)
        {
            var idx = text.IndexOf(functionName, i, StringComparison.OrdinalIgnoreCase);
            if (idx < 0)
            {
                return -1;
            }

            var beforeOk = idx == 0 || !char.IsLetterOrDigit(text[idx - 1]);
            var afterPos = idx + functionName.Length;
            var afterOk = afterPos >= text.Length || !char.IsLetterOrDigit(text[afterPos]);
            if (beforeOk && afterOk)
            {
                return idx;
            }

            i = idx + 1;
        }

        return -1;
    }

    private static int FindMatchingParen(string text, int openParenIndex)
    {
        var depth = 0;
        var inString = false;
        for (var i = openParenIndex; i < text.Length; i++)
        {
            var c = text[i];

            if (c == '"')
            {
                var escaped = i > 0 && text[i - 1] == '\\';
                if (!escaped)
                {
                    inString = !inString;
                }
            }

            if (inString)
            {
                continue;
            }

            if (c == '(')
            {
                depth++;
                continue;
            }

            if (c == ')')
            {
                depth--;
                if (depth == 0)
                {
                    return i;
                }
            }
        }

        return -1;
    }

    private static List<string> SplitTopLevelArguments(string argsText)
    {
        var args = new List<string>();
        var current = new StringBuilder();
        var parenDepth = 0;
        var braceDepth = 0;
        var bracketDepth = 0;
        var inString = false;

        for (var i = 0; i < argsText.Length; i++)
        {
            var c = argsText[i];
            var escaped = i > 0 && argsText[i - 1] == '\\';

            if (c == '"' && !escaped)
            {
                inString = !inString;
                current.Append(c);
                continue;
            }

            if (!inString)
            {
                switch (c)
                {
                    case '(':
                        parenDepth++;
                        break;
                    case ')':
                        parenDepth--;
                        break;
                    case '{':
                        braceDepth++;
                        break;
                    case '}':
                        braceDepth--;
                        break;
                    case '[':
                        bracketDepth++;
                        break;
                    case ']':
                        bracketDepth--;
                        break;
                    case ',':
                        if (parenDepth == 0 && braceDepth == 0 && bracketDepth == 0)
                        {
                            var token = current.ToString().Trim();
                            if (token.Length > 0)
                            {
                                args.Add(token);
                            }

                            current.Clear();
                            continue;
                        }

                        break;
                }
            }

            current.Append(c);
        }

        var last = current.ToString().Trim();
        if (last.Length > 0)
        {
            args.Add(last);
        }

        return args;
    }

    private static string ParseCollectionName(string firstArgument)
    {
        var arg = firstArgument?.Trim() ?? string.Empty;
        if (arg.Length == 0)
        {
            return string.Empty;
        }

        if (arg.Length >= 2 && arg[0] == '\'' && arg[^1] == '\'')
        {
            return arg[1..^1];
        }

        return IdentifierRegex.IsMatch(arg) ? arg : string.Empty;
    }

    private static HashSet<string> ExtractRequiredDataSourceNamesFromRules(
        IReadOnlyDictionary<string, JsonObject> topControlFiles,
        IReadOnlyDictionary<string, JsonObject> topComponentFiles)
    {
        var names = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        IEnumerable<JsonObject> EnumerateTopParents(IReadOnlyDictionary<string, JsonObject> files)
        {
            foreach (var v in files.Values)
            {
                if (v["TopParent"] is JsonObject top)
                {
                    yield return top;
                }
            }
        }

        foreach (var top in EnumerateTopParents(topControlFiles).Concat(EnumerateTopParents(topComponentFiles)))
        {
            foreach (var node in Flatten(top))
            {
                var rules = (node["Rules"] as JsonArray) ?? new JsonArray();
                foreach (var rule in rules.OfType<JsonObject>())
                {
                    var script = rule["InvariantScript"]?.GetValue<string>() ?? string.Empty;
                    if (string.IsNullOrWhiteSpace(script))
                    {
                        continue;
                    }

                    foreach (var call in EnumerateFunctionCalls(script, DataSourceRequiredFunctions))
                    {
                        if (call.Arguments.Count == 0)
                        {
                            continue;
                        }

                        var name = ParseCollectionName(call.Arguments[0]);
                        if (!string.IsNullOrWhiteSpace(name))
                        {
                            names.Add(name);
                        }
                    }
                }
            }
        }

        return names;
    }

    private readonly record struct ResolvedTemplate(string TemplateId, string TemplateName, string Version, JsonObject? TemplatePrototype);

    private readonly record struct UsedTemplate(string Name, string Version, string Id, string TemplateXml);

    private readonly record struct FunctionCall(string FunctionName, List<string> Arguments);

    private sealed class TemplateResolver
    {
        private readonly Dictionary<string, ResolvedTemplate> _byAlias = new(StringComparer.OrdinalIgnoreCase);

        public void RegisterControlType(string controlType, JsonObject controlNode)
        {
            var template = controlNode["Template"] as JsonObject;
            if (template is null)
            {
                return;
            }

            RegisterAlias(
                NormalizeControlType(controlType),
                template["Id"]?.GetValue<string>(),
                template["Name"]?.GetValue<string>(),
                template["Version"]?.GetValue<string>(),
                template);
        }

        public void RegisterTemplateFromControlNode(JsonObject controlNode)
        {
            var template = controlNode["Template"] as JsonObject;
            if (template is null)
            {
                return;
            }

            var templateId = template["Id"]?.GetValue<string>() ?? string.Empty;
            var templateName = template["Name"]?.GetValue<string>() ?? string.Empty;
            var version = template["Version"]?.GetValue<string>() ?? string.Empty;

            RegisterTemplate(templateName, templateId, version, template);
            RegisterAlias(NormalizeAliasFromId(templateId), templateId, templateName, version, template);
        }

        public void RegisterTemplate(string name, string id, string version, JsonObject? templatePrototype = null)
        {
            RegisterAlias(NormalizeAlias(name), id, name, version, templatePrototype);
            RegisterAlias(NormalizeAliasFromId(id), id, name, version, templatePrototype);
        }

        public bool TryResolve(string controlType, out ResolvedTemplate template)
        {
            template = default;
            var normalizedType = NormalizeControlType(controlType);
            if (string.IsNullOrWhiteSpace(normalizedType))
            {
                return false;
            }

            if (!_byAlias.TryGetValue(normalizedType, out var found))
            {
                return false;
            }

            var requestedVersion = ParseRequestedVersion(controlType);
            template = string.IsNullOrWhiteSpace(requestedVersion)
                ? found
                : found with { Version = requestedVersion };

            return true;
        }

        private void RegisterAlias(string alias, string? id, string? name, string? version, JsonObject? templatePrototype = null)
        {
            if (string.IsNullOrWhiteSpace(alias) || string.IsNullOrWhiteSpace(id) || string.IsNullOrWhiteSpace(name))
            {
                return;
            }

            if (!_byAlias.ContainsKey(alias))
            {
                _byAlias[alias] = new ResolvedTemplate(
                    id,
                    name,
                    string.IsNullOrWhiteSpace(version) ? "1.0.0" : version,
                    templatePrototype is null ? null : (JsonObject)templatePrototype.DeepClone());
            }
            else if (templatePrototype is not null && _byAlias[alias].TemplatePrototype is null)
            {
                var existing = _byAlias[alias];
                _byAlias[alias] = existing with { TemplatePrototype = (JsonObject)templatePrototype.DeepClone() };
            }
        }

        private static string NormalizeControlType(string controlType)
        {
            var raw = controlType?.Trim() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(raw))
            {
                return string.Empty;
            }

            var at = raw.Split('@', 2, StringSplitOptions.TrimEntries);
            var typePart = at[0];
            var slash = typePart.Split('/', 2, StringSplitOptions.TrimEntries);
            var canonical = slash.Length == 2 ? slash[1] : slash[0];
            if (string.Equals(canonical, "TextInput", StringComparison.OrdinalIgnoreCase))
            {
                canonical = "PowerApps_CoreControls_TextInputCanvas";
            }

            return NormalizeAlias(canonical);
        }

        private static string ParseRequestedVersion(string controlType)
        {
            var raw = controlType?.Trim() ?? string.Empty;
            if (string.IsNullOrWhiteSpace(raw))
            {
                return string.Empty;
            }

            var at = raw.Split('@', 2, StringSplitOptions.TrimEntries);
            return at.Length > 1 ? at[1] : string.Empty;
        }

        private static string NormalizeAlias(string value)
        {
            return (value ?? string.Empty).Trim().ToLowerInvariant();
        }

        private static string NormalizeAliasFromId(string id)
        {
            if (string.IsNullOrWhiteSpace(id))
            {
                return string.Empty;
            }

            var trimmed = id.TrimEnd('/');
            var idx = trimmed.LastIndexOf('/');
            var tail = idx >= 0 ? trimmed[(idx + 1)..] : trimmed;
            return NormalizeAlias(tail);
        }
    }

    private sealed class TemplatePropertyResolver
    {
        private readonly Dictionary<string, HashSet<string>> _allowedByTemplateKey = new(StringComparer.OrdinalIgnoreCase);

        public void RegisterTemplateProperties(string templateName, string templateId, IEnumerable<string> properties)
        {
            var names = properties.Where(p => !string.IsNullOrWhiteSpace(p)).ToList();
            if (names.Count == 0)
            {
                return;
            }

            foreach (var key in GetTemplateKeys(templateName, templateId))
            {
                if (!_allowedByTemplateKey.TryGetValue(key, out var set))
                {
                    set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                    _allowedByTemplateKey[key] = set;
                }

                foreach (var p in names)
                {
                    set.Add(p);
                }
            }
        }

        public void RegisterFromControlNode(JsonObject node)
        {
            var templateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
            var templateId = node["Template"]?["Id"]?.GetValue<string>() ?? string.Empty;
            var ruleProps = ((node["Rules"] as JsonArray) ?? new JsonArray())
                .OfType<JsonObject>()
                .Select(r => r["Property"]?.GetValue<string>() ?? string.Empty)
                .Where(p => !string.IsNullOrWhiteSpace(p));

            RegisterTemplateProperties(templateName, templateId, ruleProps);
        }

        public bool TryGetAllowedProperties(JsonObject node, out HashSet<string> properties)
        {
            properties = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            var templateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
            var templateId = node["Template"]?["Id"]?.GetValue<string>() ?? string.Empty;

            var found = false;
            foreach (var key in GetTemplateKeys(templateName, templateId))
            {
                if (_allowedByTemplateKey.TryGetValue(key, out var set))
                {
                    properties.UnionWith(set);
                    found = true;
                }
            }

            return found;
        }

        private static IEnumerable<string> GetTemplateKeys(string templateName, string templateId)
        {
            if (!string.IsNullOrWhiteSpace(templateName))
            {
                yield return templateName.Trim().ToLowerInvariant();
            }

            if (string.IsNullOrWhiteSpace(templateId))
            {
                yield break;
            }

            var normalizedId = templateId.Trim().ToLowerInvariant();
            yield return normalizedId;

            var trimmed = normalizedId.TrimEnd('/');
            var idx = trimmed.LastIndexOf('/');
            if (idx >= 0 && idx < trimmed.Length - 1)
            {
                yield return trimmed[(idx + 1)..];
            }
        }
    }

    private sealed class TemplateKeywordResolver
    {
        private readonly Dictionary<string, HashSet<string>> _requiredByTemplateKey = new(StringComparer.OrdinalIgnoreCase);

        public void RegisterTemplateKeywords(string templateName, string templateId, IEnumerable<string> requiredKeywords)
        {
            var keywords = requiredKeywords.Where(k => !string.IsNullOrWhiteSpace(k)).ToList();
            if (keywords.Count == 0)
            {
                return;
            }

            foreach (var key in GetTemplateKeys(templateName, templateId))
            {
                if (!_requiredByTemplateKey.TryGetValue(key, out var set))
                {
                    set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                    _requiredByTemplateKey[key] = set;
                }

                foreach (var keyword in keywords)
                {
                    set.Add(keyword);
                }
            }
        }

        public void RegisterFromControlNode(JsonObject node)
        {
            var templateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
            var templateId = node["Template"]?["Id"]?.GetValue<string>() ?? string.Empty;
            var variantName = node["VariantName"]?.GetValue<string>() ?? string.Empty;

            if (!string.IsNullOrWhiteSpace(variantName))
            {
                RegisterTemplateKeywords(templateName, templateId, ["Variant"]);
            }
        }

        public bool TryGetRequiredKeywords(JsonObject node, out HashSet<string> requiredKeywords)
        {
            requiredKeywords = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            var templateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
            var templateId = node["Template"]?["Id"]?.GetValue<string>() ?? string.Empty;

            var found = false;
            foreach (var key in GetTemplateKeys(templateName, templateId))
            {
                if (_requiredByTemplateKey.TryGetValue(key, out var set))
                {
                    requiredKeywords.UnionWith(set);
                    found = true;
                }
            }

            return found;
        }

        private static IEnumerable<string> GetTemplateKeys(string templateName, string templateId)
        {
            if (!string.IsNullOrWhiteSpace(templateName))
            {
                yield return templateName.Trim().ToLowerInvariant();
            }

            if (string.IsNullOrWhiteSpace(templateId))
            {
                yield break;
            }

            var normalizedId = templateId.Trim().ToLowerInvariant();
            yield return normalizedId;

            var trimmed = normalizedId.TrimEnd('/');
            var idx = trimmed.LastIndexOf('/');
            if (idx >= 0 && idx < trimmed.Length - 1)
            {
                yield return trimmed[(idx + 1)..];
            }
        }
    }

    private sealed class ControlMetadataResolver
    {
        private readonly Dictionary<string, string> _categoryByTemplateAndProperty = new(StringComparer.OrdinalIgnoreCase);
        private readonly Dictionary<string, string> _datatypeByTemplateAndProperty = new(StringComparer.OrdinalIgnoreCase);
        private readonly Dictionary<string, Dictionary<string, int>> _styleHistogram = new(StringComparer.OrdinalIgnoreCase);
        private readonly Dictionary<string, JsonArray> _rulesPrototypeByTemplate = new(StringComparer.OrdinalIgnoreCase);
        private readonly Dictionary<string, JsonArray> _statePrototypeByTemplate = new(StringComparer.OrdinalIgnoreCase);
        private readonly Dictionary<string, bool> _hasDynamicPropertiesByTemplate = new(StringComparer.OrdinalIgnoreCase);

        public void RegisterTemplatePropertyDatatypesFromXml(string templateName, string templateId, string templateXml)
        {
            if (string.IsNullOrWhiteSpace(templateXml))
            {
                return;
            }

            try
            {
                var root = XDocument.Parse(templateXml).Root;
                if (root is null)
                {
                    return;
                }

                foreach (var prop in root.Descendants().Where(e => e.Name.LocalName == "property"))
                {
                    var name = prop.Attribute("name")?.Value ?? string.Empty;
                    var datatype = prop.Attribute("datatype")?.Value ?? string.Empty;
                    if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(datatype))
                    {
                        continue;
                    }

                    foreach (var key in GetTemplateKeys(templateName, templateId))
                    {
                        var composite = $"{key}|{name}";
                        if (!_datatypeByTemplateAndProperty.ContainsKey(composite))
                        {
                            _datatypeByTemplateAndProperty[composite] = datatype;
                        }
                    }
                }
            }
            catch
            {
                // Ignore malformed template xml.
            }
        }

        public void NormalizeReservedEnumTokensInTopFiles(IReadOnlyDictionary<string, JsonObject> topFiles)
        {
            foreach (var topFile in topFiles.Values)
            {
                if (topFile["TopParent"] is not JsonObject topParent)
                {
                    continue;
                }

                foreach (var node in Flatten(topParent))
                {
                    NormalizeReservedEnumTokensInRules(node);
                }
            }
        }

        public void NormalizeReservedEnumTokensInRules(JsonObject node)
        {
            var rules = node["Rules"] as JsonArray;
            if (rules is null || rules.Count == 0)
            {
                return;
            }

            var templateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
            var templateId = node["Template"]?["Id"]?.GetValue<string>() ?? string.Empty;

            foreach (var rule in rules.OfType<JsonObject>())
            {
                var property = rule["Property"]?.GetValue<string>() ?? string.Empty;
                if (string.IsNullOrWhiteSpace(property))
                {
                    continue;
                }

                var datatype = ResolveDatatype(templateName, templateId, property);
                var expectedEnumType = string.IsNullOrWhiteSpace(datatype) ? property : datatype;

                var invariantScript = rule["InvariantScript"]?.GetValue<string>() ?? string.Empty;
                if (string.IsNullOrWhiteSpace(invariantScript))
                {
                    continue;
                }

                var normalized = NormalizeReservedEnumTokenForDatatype(invariantScript, expectedEnumType);
                if (string.Equals(normalized, invariantScript, StringComparison.Ordinal))
                {
                    normalized = NormalizeReservedEnumToken(invariantScript);
                }

                if (!string.Equals(invariantScript, normalized, StringComparison.Ordinal))
                {
                    rule["InvariantScript"] = normalized;
                }
            }
        }

        private string? ResolveDatatype(string templateName, string templateId, string property)
        {
            foreach (var key in GetTemplateKeys(templateName, templateId))
            {
                var composite = $"{key}|{property}";
                if (_datatypeByTemplateAndProperty.TryGetValue(composite, out var datatype)
                    && !string.IsNullOrWhiteSpace(datatype))
                {
                    return datatype;
                }
            }

            return null;
        }

        public void RegisterFromControlNode(JsonObject node)
        {
            var templateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
            var templateId = node["Template"]?["Id"]?.GetValue<string>() ?? string.Empty;
            var keys = GetTemplateKeys(templateName, templateId);
            if (keys.Count == 0)
            {
                return;
            }

            var styleName = node["StyleName"]?.GetValue<string>() ?? string.Empty;
            if (!string.IsNullOrWhiteSpace(styleName))
            {
                foreach (var key in keys)
                {
                    if (!_styleHistogram.TryGetValue(key, out var map))
                    {
                        map = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
                        _styleHistogram[key] = map;
                    }

                    map[styleName] = map.TryGetValue(styleName, out var count) ? count + 1 : 1;
                }
            }

            var rules = (node["Rules"] as JsonArray) ?? new JsonArray();
            var states = (node["ControlPropertyState"] as JsonArray) ?? new JsonArray();

            foreach (var key in keys)
            {
                if (rules.Count > 0)
                {
                    if (!_rulesPrototypeByTemplate.TryGetValue(key, out var existingRules)
                        || existingRules.Count < rules.Count)
                    {
                        _rulesPrototypeByTemplate[key] = (JsonArray)rules.DeepClone();
                    }
                }

                if (states.Count > 0)
                {
                    if (!_statePrototypeByTemplate.TryGetValue(key, out var existingStates)
                        || existingStates.Count < states.Count)
                    {
                        _statePrototypeByTemplate[key] = (JsonArray)states.DeepClone();
                    }
                }

                if (!_hasDynamicPropertiesByTemplate.ContainsKey(key) && node["HasDynamicProperties"] is JsonValue hv && hv.TryGetValue<bool>(out var hasDynamic))
                {
                    _hasDynamicPropertiesByTemplate[key] = hasDynamic;
                }
            }

            foreach (var rule in rules.OfType<JsonObject>())
            {
                var property = rule["Property"]?.GetValue<string>() ?? string.Empty;
                var category = rule["Category"]?.GetValue<string>() ?? string.Empty;
                if (string.IsNullOrWhiteSpace(property) || string.IsNullOrWhiteSpace(category))
                {
                    continue;
                }

                foreach (var key in keys)
                {
                    var composite = $"{key}|{property}";
                    if (!_categoryByTemplateAndProperty.ContainsKey(composite))
                    {
                        _categoryByTemplateAndProperty[composite] = category;
                    }
                }
            }
        }

        public string? ResolveCategory(JsonObject node, string property)
        {
            var templateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
            var templateId = node["Template"]?["Id"]?.GetValue<string>() ?? string.Empty;
            foreach (var key in GetTemplateKeys(templateName, templateId))
            {
                var composite = $"{key}|{property}";
                if (_categoryByTemplateAndProperty.TryGetValue(composite, out var category)
                    && !string.IsNullOrWhiteSpace(category))
                {
                    return category;
                }
            }

            return null;
        }

        public string? ResolveStyle(JsonObject node)
        {
            var templateName = node["Template"]?["Name"]?.GetValue<string>() ?? string.Empty;
            var templateId = node["Template"]?["Id"]?.GetValue<string>() ?? string.Empty;

            foreach (var key in GetTemplateKeys(templateName, templateId))
            {
                if (!_styleHistogram.TryGetValue(key, out var map) || map.Count == 0)
                {
                    continue;
                }

                var defaultStyle = map
                    .Where(kv => kv.Key.StartsWith("default", StringComparison.OrdinalIgnoreCase))
                    .OrderByDescending(kv => kv.Value)
                    .ThenBy(kv => kv.Key, StringComparer.OrdinalIgnoreCase)
                    .FirstOrDefault();

                if (!string.IsNullOrWhiteSpace(defaultStyle.Key))
                {
                    return defaultStyle.Key;
                }

                var best = map.OrderByDescending(kv => kv.Value).ThenBy(kv => kv.Key, StringComparer.OrdinalIgnoreCase).First();
                if (!string.IsNullOrWhiteSpace(best.Key))
                {
                    return best.Key;
                }
            }

            return null;
        }

        public void ApplyTemplateDefaults(JsonObject node, string templateName, string templateId)
        {
            var keys = GetTemplateKeys(templateName, templateId);
            if (keys.Count == 0)
            {
                return;
            }

            var rules = node["Rules"] as JsonArray;
            if (rules is null || rules.Count == 0)
            {
                foreach (var key in keys)
                {
                    if (_rulesPrototypeByTemplate.TryGetValue(key, out var prototypeRules) && prototypeRules.Count > 0)
                    {
                        node["Rules"] = prototypeRules.DeepClone();
                        break;
                    }
                }
            }

            var state = node["ControlPropertyState"] as JsonArray;
            if (state is null || state.Count == 0)
            {
                foreach (var key in keys)
                {
                    if (_statePrototypeByTemplate.TryGetValue(key, out var prototypeState) && prototypeState.Count > 0)
                    {
                        node["ControlPropertyState"] = prototypeState.DeepClone();
                        break;
                    }
                }
            }

            if (node["HasDynamicProperties"] is null)
            {
                foreach (var key in keys)
                {
                    if (_hasDynamicPropertiesByTemplate.TryGetValue(key, out var hasDynamic))
                    {
                        node["HasDynamicProperties"] = hasDynamic;
                        break;
                    }
                }
            }

            NormalizeReservedEnumTokensInRules(node);
            UpdateControlPropertyStateFromRules(node);

            EnsureModernTextInputBaseline(node, templateName, templateId);
        }

        private static void EnsureModernTextInputBaseline(JsonObject node, string templateName, string templateId)
        {
            var isModernTextInput = string.Equals(templateName, "PowerApps_CoreControls_TextInputCanvas", StringComparison.OrdinalIgnoreCase)
                                    || templateId.Contains("PowerApps_CoreControls_TextInputCanvas", StringComparison.OrdinalIgnoreCase);
            if (!isModernTextInput)
            {
                return;
            }

            var rules = (node["Rules"] as JsonArray) ?? new JsonArray();

            void EnsureRule(string property, string category, string invariantScript)
            {
                var existing = rules
                    .OfType<JsonObject>()
                    .FirstOrDefault(r => string.Equals(r["Property"]?.GetValue<string>() ?? string.Empty, property, StringComparison.OrdinalIgnoreCase));

                if (existing is null)
                {
                    rules.Add(new JsonObject
                    {
                        ["Property"] = property,
                        ["Category"] = category,
                        ["InvariantScript"] = invariantScript,
                        ["RuleProviderType"] = "Unknown",
                    });

                    return;
                }

                existing["Category"] ??= category;
                existing["RuleProviderType"] ??= "Unknown";
                if (existing["InvariantScript"] is null)
                {
                    existing["InvariantScript"] = invariantScript;
                }
            }

            EnsureRule("Align", "Data", "\"\"");
            EnsureRule("AccessibleLabel", "Data", "\"\"");
            EnsureRule("MaxLength", "Data", "-1");
            EnsureRule("Mode", "Data", "\"SingleLine\"");
            EnsureRule("Placeholder", "Data", "\"\"");
            EnsureRule("Required", "Data", "false");
            EnsureRule("Type", "Data", "\"Text\"");
            EnsureRule("ValidationState", "Data", "\"None\"");
            EnsureRule("Value", "Data", "\"\"");
            EnsureRule("Font", "Data", "\"\"");
            EnsureRule("FontSize", "Data", "0");
            EnsureRule("FontWeight", "Data", "\"\"");
            EnsureRule("FontItalic", "Data", "false");
            EnsureRule("FontUnderline", "Data", "false");
            EnsureRule("FontStrikethrough", "Data", "false");
            EnsureRule("Appearance", "Data", "\"FilledDarker\"");
            EnsureRule("BorderStyle", "Data", "\"\"");
            EnsureRule("TriggerOutput", "Data", "\"FocusOut\"");
            EnsureRule("ContentLanguage", "Data", "\"\"");
            EnsureRule("BasePaletteColor", "Data", "");
            EnsureRule("FontColor", "Data", "");
            EnsureRule("Fill", "Data", "");
            EnsureRule("BorderColor", "Data", "");
            EnsureRule("ZIndex", "Design", "2");
            EnsureRule("TabIndex", "Design", "0");
            EnsureRule("Tooltip", "Design", "\"\"");
            EnsureRule("X", "Design", "0");
            EnsureRule("Y", "Design", "0");
            EnsureRule("Width", "Design", "Parent.Width");
            EnsureRule("Height", "Design", "32");
            EnsureRule("Visible", "Design", "true");
            EnsureRule("DisplayMode", "Design", "DisplayMode.Edit");
            EnsureRule("OnChange", "Behavior", "false");

            node["Rules"] = rules;
            UpdateControlPropertyStateFromRules(node);

            node["HasDynamicProperties"] = true;
            if (node["DynamicProperties"] is not JsonArray dynamicProperties)
            {
                dynamicProperties = new JsonArray();
                node["DynamicProperties"] = dynamicProperties;
            }

            void EnsureDynamicProperty(string propertyName, string category, string invariantScript)
            {
                var existing = dynamicProperties
                    .OfType<JsonObject>()
                    .FirstOrDefault(d => string.Equals(d["PropertyName"]?.GetValue<string>() ?? string.Empty, propertyName, StringComparison.OrdinalIgnoreCase));

                if (existing is not null)
                {
                    return;
                }

                dynamicProperties.Add(new JsonObject
                {
                    ["PropertyName"] = propertyName,
                    ["Rule"] = new JsonObject
                    {
                        ["Property"] = propertyName,
                        ["Category"] = category,
                        ["InvariantScript"] = invariantScript,
                        ["RuleProviderType"] = "Unknown",
                    },
                    ["ControlPropertyState"] = propertyName,
                });
            }

            EnsureDynamicProperty("FillPortions", "Design", "0");
            EnsureDynamicProperty("AlignInContainer", "Design", "AlignInContainer.SetByContainer");
            EnsureDynamicProperty("LayoutMinWidth", "Design", "320");
            EnsureDynamicProperty("LayoutMinHeight", "Design", "32");
            EnsureDynamicProperty("LayoutMaxWidth", "Design", "0");
            EnsureDynamicProperty("LayoutMaxHeight", "Design", "0");
        }

        private static List<string> GetTemplateKeys(string templateName, string templateId)
        {
            var keys = new List<string>();
            if (!string.IsNullOrWhiteSpace(templateName))
            {
                keys.Add(templateName.Trim().ToLowerInvariant());
            }

            if (!string.IsNullOrWhiteSpace(templateId))
            {
                keys.Add(templateId.Trim().ToLowerInvariant());
                var trimmed = templateId.Trim().TrimEnd('/');
                var idx = trimmed.LastIndexOf('/');
                if (idx >= 0 && idx < trimmed.Length - 1)
                {
                    keys.Add(trimmed[(idx + 1)..].ToLowerInvariant());
                }
            }

            return keys.Distinct(StringComparer.OrdinalIgnoreCase).ToList();
        }
    }

    private static JsonObject CreateDefaultControl(string name)
    {
        return new JsonObject
        {
            ["Type"] = "ControlInfo",
            ["Name"] = name,
            ["Template"] = new JsonObject
            {
                ["Id"] = "http://microsoft.com/appmagic/label",
                ["Version"] = "2.5.1",
                ["LastModifiedTimestamp"] = "0",
                ["Name"] = "label",
                ["FirstParty"] = true,
                ["IsPremiumPcfControl"] = false,
                ["IsCustomGroupControlTemplate"] = false,
                ["CustomGroupControlTemplateName"] = "",
                ["IsComponentDefinition"] = false,
                ["OverridableProperties"] = new JsonObject(),
            },
            ["Index"] = 0,
            ["PublishOrderIndex"] = 0,
            ["VariantName"] = "",
            ["LayoutName"] = "",
            ["MetaDataIDKey"] = "",
            ["PersistMetaDataIDKey"] = false,
            ["IsFromScreenLayout"] = false,
            ["StyleName"] = "",
            ["Parent"] = "",
            ["IsDataControl"] = false,
            ["AllowAccessToGlobals"] = true,
            ["OptimizeForDevices"] = "Off",
            ["IsGroupControl"] = false,
            ["IsAutoGenerated"] = false,
            ["Rules"] = new JsonArray(),
            ["ControlPropertyState"] = new JsonArray(),
            ["IsLocked"] = false,
            ["ControlUniqueId"] = "0",
            ["Children"] = new JsonArray(),
        };
    }

    private static JsonObject CreateDefaultScreen(string name)
    {
        var screen = CreateDefaultControl(name);
        var template = (JsonObject)screen["Template"]!;
        template["Id"] = "http://microsoft.com/appmagic/screen";
        template["Name"] = "screen";
        template["Version"] = "1.0";
        screen["StyleName"] = "defaultScreenStyle";
        return screen;
    }

    private static JsonObject CreateDefaultComponent(string name)
    {
        var component = CreateDefaultControl(name);
        var template = (JsonObject)component["Template"]!;
        template["Id"] = "http://microsoft.com/appmagic/Component";
        template["Name"] = Guid.NewGuid().ToString("N");
        template["Version"] = "1.0";
        template["IsComponentDefinition"] = true;
        component["AllowAccessToGlobals"] = false;
        return component;
    }

    private static JsonObject WrapTopParent(JsonObject topParent)
    {
        return new JsonObject { ["TopParent"] = topParent.DeepClone() };
    }

    private static void IndexByName(JsonObject node, Dictionary<string, JsonObject> index)
    {
        var name = node["Name"]?.GetValue<string>() ?? string.Empty;
        if (!string.IsNullOrWhiteSpace(name) && !index.ContainsKey(name))
        {
            index[name] = node;
        }

        foreach (var child in (node["Children"] as JsonArray ?? []).OfType<JsonObject>())
        {
            IndexByName(child, index);
        }
    }

    private static IEnumerable<JsonObject> Flatten(JsonObject node)
    {
        yield return node;
        foreach (var child in (node["Children"] as JsonArray ?? []).OfType<JsonObject>())
        {
            foreach (var nested in Flatten(child))
            {
                yield return nested;
            }
        }
    }

    private static Dictionary<string, JsonObject> ParseTopParentFiles(Dictionary<string, byte[]> entries, string folderPrefix)
    {
        var map = new Dictionary<string, JsonObject>(StringComparer.OrdinalIgnoreCase);
        foreach (var (path, bytes) in entries.Where(e => e.Key.StartsWith(folderPrefix, StringComparison.OrdinalIgnoreCase) && e.Key.EndsWith(".json", StringComparison.OrdinalIgnoreCase)))
        {
            var parsed = JsonNode.Parse(bytes)?.AsObject();
            if (parsed is not null)
            {
                map[path] = parsed;
            }
        }

        return map;
    }

    private static bool TryParseYamlMap(IDeserializer deserializer, string yaml, out Dictionary<object, object?> root)
    {
        root = new Dictionary<object, object?>();
        try
        {
            var parsed = deserializer.Deserialize<Dictionary<object, object?>>(yaml);
            if (parsed is null)
            {
                return false;
            }

            root = parsed;
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static bool TryGetMap(Dictionary<object, object?> source, string key, out Dictionary<object, object?> map)
    {
        map = new Dictionary<object, object?>();
        if (!source.TryGetValue(key, out var val) || val is not Dictionary<object, object?> dict)
        {
            return false;
        }

        map = dict;
        return true;
    }

    private static Dictionary<string, byte[]> ReadEntries(string directory)
    {
        var entries = new Dictionary<string, byte[]>(StringComparer.OrdinalIgnoreCase);
        foreach (var path in Directory.GetFiles(directory, "*", SearchOption.AllDirectories))
        {
            var rel = Path.GetRelativePath(directory, path).Replace('\\', '/');
            entries[rel] = File.ReadAllBytes(path);
        }

        return entries;
    }

    private static void WriteMsApp(Dictionary<string, byte[]> entries, string outputMsappPath)
    {
        if (File.Exists(outputMsappPath))
        {
            File.Delete(outputMsappPath);
        }

        using var archive = ZipFile.Open(outputMsappPath, ZipArchiveMode.Create);
        foreach (var (path, data) in entries.OrderBy(e => e.Key, StringComparer.OrdinalIgnoreCase))
        {
            var entry = archive.CreateEntry(path, CompressionLevel.Optimal);
            using var stream = entry.Open();
            stream.Write(data, 0, data.Length);
        }
    }

    private static void WriteEntriesToDirectory(Dictionary<string, byte[]> entries, string outputDirectory)
    {
        foreach (var (path, data) in entries.OrderBy(e => e.Key, StringComparer.OrdinalIgnoreCase))
        {
            var fullPath = Path.Combine(outputDirectory, path.Replace('/', Path.DirectorySeparatorChar));
            var dir = Path.GetDirectoryName(fullPath);
            if (!string.IsNullOrWhiteSpace(dir))
            {
                Directory.CreateDirectory(dir);
            }

            File.WriteAllBytes(fullPath, data);
        }
    }

    private static JsonObject CreateDefaultApp(string startScreen)
    {
        var app = CreateDefaultControl("App");
        var template = (JsonObject)app["Template"]!;
        template["Id"] = "http://microsoft.com/appmagic/appinfo";
        template["Name"] = "appinfo";
        template["Version"] = "1.0";
        app["ControlUniqueId"] = "1";
        app["IsDataControl"] = true;
        app["Rules"] = new JsonArray
        {
            new JsonObject { ["Property"] = "ConfirmExit", ["Category"] = "Data", ["InvariantScript"] = "false", ["RuleProviderType"] = "Unknown" },
            new JsonObject { ["Property"] = "BackEnabled", ["Category"] = "Data", ["InvariantScript"] = "true", ["RuleProviderType"] = "Unknown" },
            new JsonObject { ["Property"] = "MinScreenHeight", ["Category"] = "Design", ["InvariantScript"] = "320", ["RuleProviderType"] = "Unknown" },
            new JsonObject { ["Property"] = "MinScreenWidth", ["Category"] = "Design", ["InvariantScript"] = "320", ["RuleProviderType"] = "Unknown" },
            new JsonObject { ["Property"] = "Theme", ["Category"] = "Design", ["InvariantScript"] = "PowerAppsTheme", ["RuleProviderType"] = "Unknown" },
            new JsonObject { ["Property"] = "OnStart", ["Category"] = "Behavior", ["InvariantScript"] = "false", ["RuleProviderType"] = "Unknown" },
            new JsonObject { ["Property"] = "SizeBreakpoints", ["Category"] = "ConstantData", ["InvariantScript"] = "[600, 900, 1200]", ["RuleProviderType"] = "Unknown" },
            new JsonObject { ["Property"] = "StartScreen", ["Category"] = "OnDemandData", ["InvariantScript"] = startScreen, ["RuleProviderType"] = "Unknown" },
        };
        app["ControlPropertyState"] = new JsonArray("ConfirmExit", "BackEnabled", "MinScreenHeight", "MinScreenWidth", "Theme", "OnStart", "SizeBreakpoints", "StartScreen");

        var host = CreateDefaultControl("Host");
        var hostTemplate = (JsonObject)host["Template"]!;
        hostTemplate["Id"] = "http://microsoft.com/appmagic/hostcontrol";
        hostTemplate["Name"] = "hostControl";
        hostTemplate["Version"] = "1.6.0";
        host["Parent"] = "App";
        host["VariantName"] = "DefaultHostControlVariant";
        host["IsDataControl"] = true;
        host["HasDynamicProperties"] = false;
        host["ControlUniqueId"] = "3";
        host["Rules"] = new JsonArray
        {
            new JsonObject { ["Property"] = "OnNew", ["Category"] = "Behavior", ["InvariantScript"] = "false", ["RuleProviderType"] = "Unknown" },
            new JsonObject { ["Property"] = "OnEdit", ["Category"] = "Behavior", ["InvariantScript"] = "false", ["RuleProviderType"] = "Unknown" },
            new JsonObject { ["Property"] = "OnView", ["Category"] = "Behavior", ["InvariantScript"] = "false", ["RuleProviderType"] = "Unknown" },
            new JsonObject { ["Property"] = "OnSave", ["Category"] = "Behavior", ["InvariantScript"] = "false", ["RuleProviderType"] = "Unknown" },
            new JsonObject { ["Property"] = "OnCancel", ["Category"] = "Behavior", ["InvariantScript"] = "false", ["RuleProviderType"] = "Unknown" },
        };
        host["ControlPropertyState"] = new JsonArray("OnNew", "OnEdit", "OnView", "OnSave", "OnCancel");

        app["Children"] = new JsonArray(host);
        return app;
    }

    private sealed class ControlIdAllocator
    {
        private readonly HashSet<int> _used = [];
        private readonly Dictionary<string, int> _nameMap = new(StringComparer.OrdinalIgnoreCase);
        private int _max;

        public ControlIdAllocator(IEnumerable<string> existing)
        {
            foreach (var id in existing)
            {
                if (int.TryParse(id, NumberStyles.Integer, CultureInfo.InvariantCulture, out var i))
                {
                    _used.Add(i);
                    if (i > _max)
                    {
                        _max = i;
                    }
                }
            }
        }

        public string GetOrCreate(string name, JsonObject? existing)
        {
            if (_nameMap.TryGetValue(name, out var mapped))
            {
                return mapped.ToString(CultureInfo.InvariantCulture);
            }

            if (existing is not null && int.TryParse(existing["ControlUniqueId"]?.GetValue<string>(), NumberStyles.Integer, CultureInfo.InvariantCulture, out var preserved))
            {
                _used.Add(preserved);
                _nameMap[name] = preserved;
                if (preserved > _max)
                {
                    _max = preserved;
                }

                return preserved.ToString(CultureInfo.InvariantCulture);
            }

            var next = _max + 1;
            while (_used.Contains(next))
            {
                next++;
            }

            _used.Add(next);
            _max = next;
            _nameMap[name] = next;
            return next.ToString(CultureInfo.InvariantCulture);
        }
    }

    private static readonly string[] HeaderLines =
    [
        "# ************************************************************************************************",
        "# Warning: YAML source code for Canvas Apps should only be used to review changes made within Power Apps Studio and for minor edits (Preview).",
        "# Use the maker portal to create and edit your Power Apps.",
        "# ",
        "# The schema file for Canvas Apps is available at https://go.microsoft.com/fwlink/?linkid=2304907",
        "# ",
        "# For more information, visit https://go.microsoft.com/fwlink/?linkid=2292623",
        "# ************************************************************************************************",
    ];

    private static readonly Regex CollectionFunctionRegex = new(
        @"\b(?:ClearCollect|Collect)\s*\(\s*(?:'([^']+)'|([A-Za-z_][A-Za-z0-9_]*))",
        RegexOptions.Compiled | RegexOptions.CultureInvariant | RegexOptions.IgnoreCase);

    private static readonly string[] DataSourceRequiredFunctions =
    [
        "Patch",
        "Remove",
        "RemoveIf",
        "Update",
        "UpdateIf",
        "Defaults",
        "Refresh",
    ];

    private static readonly string[] CollectionSeedFunctions =
    [
        "Collect",
        "ClearCollect",
    ];

    private static readonly Regex IdentifierRegex = new(
        @"^[A-Za-z_][A-Za-z0-9_]*$",
        RegexOptions.Compiled | RegexOptions.CultureInvariant);

    private static readonly Regex RecordKeyRegex = new(
        @"(^|[,{]\s*)([A-Za-z_][A-Za-z0-9_]*)\s*:",
        RegexOptions.Compiled | RegexOptions.CultureInvariant);

    private static readonly Regex TrueFalseRegex = new(
        @"\b(true|false)\b",
        RegexOptions.Compiled | RegexOptions.CultureInvariant | RegexOptions.IgnoreCase);

    private static readonly HashSet<string> DesignProperties = new(StringComparer.OrdinalIgnoreCase)
    {
        "Align", "Appearance", "AutoHeight", "BorderColor", "BorderStyle", "BorderThickness", "Color",
        "DisabledBorderColor", "DisabledColor", "DisabledFill", "DisplayMode", "Fill", "FocusedBorderColor",
        "FocusedBorderThickness", "Font", "FontWeight", "Height", "HoverBorderColor", "HoverColor", "HoverFill",
        "IconBackground", "ImagePosition", "Italic", "LineHeight", "LoadingSpinner", "LoadingSpinnerColor",
        "Orientation", "PaddingBottom", "PaddingLeft", "PaddingRight", "PaddingTop", "PressedBorderColor",
        "PressedColor", "PressedFill", "Size", "Strikethrough", "TemplateSize", "Underline", "VerticalAlign",
        "Visible", "Width", "X", "Y", "ZIndex",
    };

    private static string BuildSchema(IReadOnlyList<(string Name, string TypeCode)> columns)
    {
        if (columns.Count == 0)
        {
            return "*[]";
        }

        return "*[" + string.Join(", ", columns.Select(c => $"{c.Name}:{c.TypeCode}")) + "]";
    }

    private static List<(string Name, string TypeCode)> InferColumns(JsonArray sampleArray)
    {
        var order = new List<string>();
        var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var typeByName = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

        foreach (var node in sampleArray)
        {
            if (node is not JsonObject row)
            {
                continue;
            }

            foreach (var kv in row)
            {
                var name = kv.Key;
                if (!seen.Contains(name))
                {
                    order.Add(name);
                    seen.Add(name);
                }

                var inferred = InferTypeCode(name, kv.Value);
                if (!typeByName.TryGetValue(name, out var current))
                {
                    typeByName[name] = inferred;
                    continue;
                }

                if (!string.Equals(current, inferred, StringComparison.OrdinalIgnoreCase))
                {
                    typeByName[name] = ResolveTypeConflict(current, inferred);
                }
            }
        }

        return order.Select(name => (name, typeByName.TryGetValue(name, out var t) ? t : "s")).ToList();
    }

    private static string ResolveTypeConflict(string left, string right)
    {
        if (string.Equals(left, right, StringComparison.OrdinalIgnoreCase))
        {
            return left;
        }

        if ((left == "n" && right == "b") || (left == "b" && right == "n"))
        {
            return "n";
        }

        return "s";
    }

    private static string InferTypeCode(string columnName, JsonNode? value)
    {
        if (value is null)
        {
            return "s";
        }

        if (value is JsonArray || value is JsonObject)
        {
            return "s";
        }

        if (value is not JsonValue scalar)
        {
            return "s";
        }

        if (scalar.TryGetValue<bool>(out _))
        {
            return "b";
        }

        if (scalar.TryGetValue<decimal>(out _))
        {
            return "n";
        }

        if (scalar.TryGetValue<string>(out var s))
        {
            if (LooksLikeImageField(columnName, s))
            {
                return "i";
            }

            return "s";
        }

        return "s";
    }

    private static bool LooksLikeImageField(string columnName, string value)
    {
        if (columnName.Contains("image", StringComparison.OrdinalIgnoreCase)
            || columnName.Contains("photo", StringComparison.OrdinalIgnoreCase)
            || columnName.Contains("icon", StringComparison.OrdinalIgnoreCase)
            || columnName.Contains("logo", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        var trimmed = value?.Trim() ?? string.Empty;
        if (trimmed.Length == 0)
        {
            return false;
        }

        return trimmed.EndsWith(".png", StringComparison.OrdinalIgnoreCase)
               || trimmed.EndsWith(".jpg", StringComparison.OrdinalIgnoreCase)
               || trimmed.EndsWith(".jpeg", StringComparison.OrdinalIgnoreCase)
               || trimmed.EndsWith(".svg", StringComparison.OrdinalIgnoreCase)
               || trimmed.StartsWith("data:image/", StringComparison.OrdinalIgnoreCase);
    }

    private static string GetRemovedDataSourcesCachePath(string unpackDirectory)
    {
        return Path.Combine(unpackDirectory, "References", RemovedDataSourcesCacheFileName);
    }

    private static void CacheRemovedDataSource(string unpackDirectory, JsonObject dataSource, int originalIndex)
    {
        var cachePath = GetRemovedDataSourcesCachePath(unpackDirectory);
        Directory.CreateDirectory(Path.GetDirectoryName(cachePath)!);

        JsonObject root;
        JsonArray removed;
        if (File.Exists(cachePath)
            && JsonNode.Parse(File.ReadAllText(cachePath)) is JsonObject existingRoot
            && existingRoot["RemovedDataSources"] is JsonArray existingRemoved)
        {
            root = existingRoot;
            removed = existingRemoved;
        }
        else
        {
            root = new JsonObject();
            removed = new JsonArray();
            root["RemovedDataSources"] = removed;
        }

        var name = dataSource["Name"]?.GetValue<string>() ?? string.Empty;
        var datasetName = dataSource["DatasetName"]?.GetValue<string>() ?? string.Empty;
        var logicalName = dataSource["LogicalName"]?.GetValue<string>() ?? string.Empty;

        for (var i = removed.Count - 1; i >= 0; i--)
        {
            if (removed[i] is not JsonObject existing)
            {
                continue;
            }

            var existingName = existing["Name"]?.GetValue<string>() ?? string.Empty;
            var existingDataset = existing["DatasetName"]?.GetValue<string>() ?? string.Empty;
            var existingLogical = existing["LogicalName"]?.GetValue<string>() ?? string.Empty;
            if (!string.Equals(existingName, name, StringComparison.OrdinalIgnoreCase)
                || !string.Equals(existingDataset, datasetName, StringComparison.OrdinalIgnoreCase)
                || !string.Equals(existingLogical, logicalName, StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            removed.RemoveAt(i);
        }

        removed.Add(new JsonObject
        {
            ["Name"] = name,
            ["DatasetName"] = datasetName,
            ["LogicalName"] = logicalName,
            ["OriginalIndex"] = originalIndex,
            ["Entry"] = dataSource.DeepClone(),
        });

        root["RemovedDataSources"] = removed;
        File.WriteAllText(cachePath, root.ToJsonString(JsonOptions));
    }

    private static bool TryRestoreRemovedDataSource(
        string unpackDirectory,
        string? requestedDataSourceName,
        string datasetName,
        string logicalName,
        out JsonObject? restoredEntry,
        out int originalIndex)
    {
        restoredEntry = null;
        originalIndex = -1;

        var cachePath = GetRemovedDataSourcesCachePath(unpackDirectory);
        if (!File.Exists(cachePath)
            || JsonNode.Parse(File.ReadAllText(cachePath)) is not JsonObject root
            || root["RemovedDataSources"] is not JsonArray removed)
        {
            return false;
        }

        JsonObject? candidate = null;
        var candidatePos = -1;
        for (var i = removed.Count - 1; i >= 0; i--)
        {
            if (removed[i] is not JsonObject item)
            {
                continue;
            }

            var itemDataset = item["DatasetName"]?.GetValue<string>() ?? string.Empty;
            var itemLogical = item["LogicalName"]?.GetValue<string>() ?? string.Empty;
            if (!string.Equals(itemDataset, datasetName, StringComparison.OrdinalIgnoreCase)
                || !string.Equals(itemLogical, logicalName, StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            var itemName = item["Name"]?.GetValue<string>() ?? string.Empty;
            if (!string.IsNullOrWhiteSpace(requestedDataSourceName)
                && !string.Equals(itemName, requestedDataSourceName, StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            candidate = item;
            candidatePos = i;
            break;
        }

        if (candidate is null || candidate["Entry"] is not JsonObject entry)
        {
            return false;
        }

        restoredEntry = (JsonObject)entry.DeepClone();
        originalIndex = candidate["OriginalIndex"]?.GetValue<int?>() ?? -1;
        removed.RemoveAt(candidatePos);
        root["RemovedDataSources"] = removed;
        File.WriteAllText(cachePath, root.ToJsonString(JsonOptions));
        return true;
    }

    private static (string DataSourcesPath, JsonObject Root, JsonArray DataSources) OpenDataSourcesDocument(string unpackDirectory)
    {
        var dataSourcesPath = Path.Combine(unpackDirectory, "References", "DataSources.json");
        Directory.CreateDirectory(Path.GetDirectoryName(dataSourcesPath)!);

        JsonObject root;
        JsonArray dataSources;
        if (File.Exists(dataSourcesPath)
            && JsonNode.Parse(File.ReadAllText(dataSourcesPath)) is JsonObject existingRoot
            && existingRoot["DataSources"] is JsonArray existingArray)
        {
            root = existingRoot;
            dataSources = existingArray;
        }
        else
        {
            root = new JsonObject();
            dataSources = new JsonArray();
            root["DataSources"] = dataSources;
        }

        return (dataSourcesPath, root, dataSources);
    }

    private static void SaveDataSourcesDocument(string unpackDirectory, JsonObject root)
    {
        var path = Path.Combine(unpackDirectory, "References", "DataSources.json");
        Directory.CreateDirectory(Path.GetDirectoryName(path)!);
        File.WriteAllText(path, root.ToJsonString(JsonOptions));
    }

    private static void UpsertDataSourceEntry(JsonArray dataSources, JsonObject newEntry, int preferredInsertIndex = -1)
    {
        var name = newEntry["Name"]?.GetValue<string>() ?? string.Empty;
        var replaced = false;
        for (var i = 0; i < dataSources.Count; i++)
        {
            if (dataSources[i] is not JsonObject ds)
            {
                continue;
            }

            var existingName = ds["Name"]?.GetValue<string>() ?? string.Empty;
            if (!string.Equals(existingName, name, StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            dataSources[i] = newEntry;
            replaced = true;
            break;
        }

        if (!replaced)
        {
            if (preferredInsertIndex >= 0 && preferredInsertIndex <= dataSources.Count)
            {
                dataSources.Insert(preferredInsertIndex, newEntry);
            }
            else
            {
                dataSources.Add(newEntry);
            }
        }
    }
}